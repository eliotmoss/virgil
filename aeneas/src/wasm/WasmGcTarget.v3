// Copyright 2016-2025 Virgil authors.  All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// TODO(wasm): codegen system ops
// TODO(wasm): stacktrace reconstruction
// XXX(wasm): improve cfg optimizer
// XXX(wasm): default init of locals

component WasmGcComponent {
	new() {
		Aeneas.registerTarget(WasmGcTarget.new("wasm-gc-test", true));
		Aeneas.registerTarget(WasmGcTarget.new("wasm-gc", false));
	}}


// Globals consist of one region, which contains the globals, numbered 0, 1, 2, ...
def GLOBALS_SPACE = AddressSpace.new("globals", false, 32, 4, Alignment.new(1), Alignment.new(1));
def GLOBALS_REGION = Region.new("globals", GLOBALS_SPACE);

// Functions are grouped into (Wasm) tables, each table its own region
// There is one overall table, and one table for each Virgil method table (mtable)
def FUNCTIONS_SPACE = AddressSpace.new("functions", false, 32, 4, Alignment.new(1), Alignment.new(1));
def FUNCTIONS_REGION = Region.new("functions", FUNCTIONS_SPACE);	// the "main" table

// information about a dispatch table entry
type DispatchInfo {
	case Abstract(method: IrMethod) {
		// a method with no implementation
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put1("dispatch function abstract method %q", method.render);
		}
	}
	case Absolute(method: IrMethod, funcIndex: u32) {
		// a function known in advance
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put2("dispatch function %d method %q", funcIndex, method.render);
		}
	}
	case Relative(method: IrMethod, adapterIndex: u32) {
		// an adapter, relative to the dispatch adapter base
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put2("dispatch adapter %d method %q", adapterIndex, method.render);
		}
	}
	def render(buf: StringBuilder) -> StringBuilder;
}

type TableInfo {
	case Dispatch(tabnum: u32, rootRcvr: Type, rootSig: Signature, sigIndex: int, entries: Vector<DispatchInfo>) {
		// a table of dispatch adapters for methods (used by CallClassSelector, etc.)
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put3("Dispatch adapter table %d, root type %q, root sig %q,",
					tabnum, rootRcvr.render, rootSig.funcType().render)
				  .put2(" sig index %d, # entries %d", sigIndex, entries.length);
		}
	}
	case Indirect(tabnum: u32, rootRcvr: Type, rootSig: Signature, entries: Vector<(IrMethod, int)>) {
		// a table of indirect adapters for methods (used by ClassGetSelector, etc.)
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put3("Indirect adapter table %d root type %q root sig %q",
					tabnum, rootRcvr.render, rootSig.funcType().render)
				  .put1(" # entries = %d", entries.length);
		}
	}
	case ReserveDispatch(mtable: IrMtable) {
		// a reservation for a dispatch adapter
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put1("Dispatch adapter table reservation for mtable for %q", mtable.render);
		}
	}
	case ReserveIndirect(mtable: IrMtable) {
		// a reservation for an indirect adapter
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put1("Indirect adapter table reservation for mtable for %q", mtable.render);
		}
	}
	def render(buf: StringBuilder) -> StringBuilder;
}

// Started from a copy of class WasmTarget
class WasmGcTarget extends Target {
	def test: bool;

	new(name: string, test) super(name) {
		typedMain = !test;
		requireMain = false;
	}

	def configureCompiler(compiler: Compiler) {
		WasmComponent.includeSection = WasmComponent.getSectionFlags(CLOptions.WASMGC_SECTIONS.get());
		WasmComponent.printSection = WasmComponent.getSectionFlags(CLOptions.PRINT_WASMGC.get());

		compiler.Reachability = true;
		compiler.NormConfig.setSignatureLimits(10000, if(CLOptions.WASM_MULTI_VALUE.val, 1000, 1));
		compiler.NormConfig.GetScalar = getScalar;

		// added for WASM-GC
		compiler.NormConfig.MixedArrays = false;
		compiler.NormConfig.ArrayLengthType = Int.getType(true, 32);
		compiler.NormConfig.ArrayIndexType = Int.getType(true, 32);
		compiler.NormConfig.RangeStartType = Int.getType(true, 32);	// 64-bit memories?
		// compiler.unboxVariantsOpt = false;	// EBM: can't change it here
		// compiler.DisableBoundsChecks = true;	// leave since there can be residual checks
		// compiler.DisableNullChecks = true;	// EBM: look into this
		// compiler.DisableLengthChecks = true;	// EBM: look into this
	}
	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {
		match (t) {
			x: EnumType => return if(x.enumDecl.tagType.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R32, once packed refs
			x: EnumSetType => return if(x.repType.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R32, once packed refs
			x: BoolType => return Scalar.B32;
			x: IntType => return if(x.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64);
			x: FloatType => return if(x.is64, Scalar.F64 | Scalar.B64, Scalar.F32 | Scalar.B32);
			// EBM: concerned about too many things matching the default ...
			// EBM: e.g., what about VoidType?
			_ => return Scalar.Ref;
		}
	}
	def configureProgram(prog: Program) {
		def intNorm = IntNormalizers.I64LE;
		var mach = MachProgram.new(prog, FUNCTIONS_SPACE, GLOBALS_SPACE, intNorm);
		prog.tprog = mach;
		MachModule.install(prog, mach);
		mach.runtime = MachRuntime.new(mach);
		// EBM: Note that Pointer use is somewhat limited on WasmGc (these restrictions are
		// not all set up yet)
		// - atContents and atElement work only on off heap ranges (give bounds trap otherwise)
		// - atObject is prohibited
		// - atField works on on off heap Refs
		var cirt = CiRuntime_TypeCon.new(MachModule.PTR_32.create0(), prog.typeCache);
		prog.typeEnv.add(cirt);
	}
	def emit(compiler: Compiler, prog: Program) {
		var context = SsaContext.new(compiler, prog);
		var rt = getRuntime(prog);
		var e: ExecuteTestCase;
		if (test) {
			e = SpecParser.parseFile(prog.ERROR, prog.files[0], prog.inputs[0]);
			rt.heapSize = e.heapSize;
		}
		var w = emitWasmModule(context, rt);
		if (test) emitTestWrappers(context, rt, w, e);
		if (CLOptions.WASM_RUN_COMMAND.val != null) emitEngineScript(CLOptions.WASM_RUN_COMMAND.val, compiler, prog);
	}
	def emitWasmModule(context: SsaContext, rt: MachRuntime) -> DataWriter {
		def pageSize = CLOptions.WASM_PAGE_SIZE.get();
		if (!Ints.isPowerOf2(pageSize)) context.fail1("expected -wasm.page-size option to be a power of 2, got %d", pageSize);

		def prog = context.prog;

		def wasm = WasmGcProgram.new(rt.mach, context, test);

		// Lower to machine level from V3 level
		def config = MachLoweringConfig.new();
		config.MachLoweringFactory = WasmGcLowering.new(wasm, this, _, _, _);
		config.ImplicitNullChecks = true;
		config.ExplicitDivChecks = false;
		config.Int32Arith = true;
		config.Int64Arith = true;
		config.IntCastFTraps = true;
		config.NativeCmpSwp = false;

		// EBM: MachProgram has some useful data structures and functions;
		// build populates things and gets components in the record queue;
		// it runs lowering, though WasmGcLowering handles some ops
		rt.mach.build(context.compiler, config);

		// (0) Populate type table
		//--------------------------------------------------------------------------------
		// This captures most types, though some may be seen only later when going through
		// IR instructions.

		// Go through all of the heap types
		// Note: importantly this processes the classes *first*, so they will be known
		// when going through other things
		if (WasmComponent.printSection.TYPE)
			prog.ERROR.addError(null, null, "Type Section", "========== Adding types from IR ==========");
		addIrTypes(prog.ir, wasm);
		if (WasmComponent.printSection.TYPE)
			prog.ERROR.addError(null, null, "Type Section", "========== Assigning type indices ==========");
		wasm.gcTypeTable.assignTypeIndices();
		// if printing out information, add source strings
		if (WasmComponent.printSection.TYPE) {
			for (i < prog.ir.classes.length) {
				var cls = prog.ir.classes[i];
				var ctype = cls.ctype;
				var name = wasm.getClassName(ctype);
				var wht = wasm.gcTypeTable.heapTypeMap[ctype];
				wht.source = StringBuilder.new().put1("class/type %s", name).extract();
			}
			for (i < prog.ir.methods.length) {
				var m = prog.ir.methods[i];
				var ms = m.source;
				if (ms == null) continue;
				var sig = wasm.getSig(m.receiver, m.sig);
				var wht = wasm.gcTypeTable.addSignature(sig);
				var name = wasm.getMethodName(m);
				wht.source = StringBuilder.new().put1("method %s", name).extract();
			}
		}

		def initialSize = 300;

		// pageAlign does not mean much for WasmGc
		def out = WasmSectionBuffer.new(Alignment.new(1), initialSize);

		// (1) Encode the WASM header
		//--------------------------------------------------------------------------------
		out.put_b32(WasmCommon.WASM_MAGIC);
		out.put_b32(WasmCommon.WASM_VERSION);

		var sizepos: int, start: int;

		// Add the allocation stub if the program might dynamically
		// allocate memory.
		def m = rt.mach;

		// Add all the method signatures to the signatures vector and
		// assign function numbers.
		// This will include the allocation and entry stubs (if any)
		// and all non-imported functions.
		def methods = wasm.addIrMethods();

		// The work of these MachProgram calls is done in this module
		// since WasmGc has rather different notions about data,
		// addresses, and so on.

		layoutAllRecordsAndFuncs(m);

		// Generate WASM code into the code buffer. Lowering populates
		// the signatures and requests individual indirect adapters,
		// and indirect and dispatch tables, which must happen before
		// these can be emitted.
		def codebuf = MachDataWriter.new(Alignment.new(1), 0, initialSize);

		// Lowering has set up individual indirectly-referenced
		// functions.  These go into table 0.
		def numIndividualIndirectAdapters = wasm.indirectAdapterRequests.length;
		def needTable0 = (numIndividualIndirectAdapters > 0);
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put2("# of individual indirect adapters = %d, will %semit a table",
							  numIndividualIndirectAdapters, if(needTable0, "", "not "));
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		var nextTableNum = if(needTable0, 1, 0);

		// Add all the indirect adapter methods from method tables.
		// This also adds their signatures.
		def firstIndirectTable = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# of indirect tables = %d", wasm.indirectTableRequests.length);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		for (i < wasm.indirectTableRequests.length) {
			// EBM build table entries and assign function numbers
			var mtable = wasm.indirectTableRequests[i];
			if (WasmComponent.printSection.FUNCTION ||
			    WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Indirect table %d for %q", nextTableNum, mtable.render);
				prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
			wasm.indirectTableFor[mtable] = nextTableNum++;
			for (m in mtable.table) {
				if (m != null) wasm.requestIndirectAdapter(m);
			}
		}

		// Add all the dispatch adapter methods from method tables.
		// This also add the signature of the root method, which is
		// the signature of all the other dispatch methods.
		def firstDispatchTable = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# of dispatch tables = %d", wasm.dispatchTableRequests.length);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		for (i < wasm.dispatchTableRequests.length) {
			// EBM build table entries and assign function numbers
			var mtable = wasm.dispatchTableRequests[i];
			if (WasmComponent.printSection.FUNCTION ||
			    WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Dispatch table %d for %q", nextTableNum, mtable.render);
				prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
			wasm.dispatchTableFor[mtable] = nextTableNum++;

			var root: IrMethod = mtable.root;
			var sigIdx = wasm.addSig(root.receiver, root.sig);	// make sure signature is present
			var superIdx = root.machIndex;
			var superDispatch: DispatchInfo;
			if (superIdx < 0) {
				superDispatch = DispatchInfo.Abstract(mtable.root);
			} else {
				superDispatch = DispatchInfo.Absolute(mtable.root, u32.!(superIdx));
			}
			var dispTable = Vector<DispatchInfo>.new();
			for (m in mtable.table) {
				if (m != null) {
					if (root == null) {
						root = m;
						superIdx = root.machIndex;
						superDispatch = DispatchInfo.Absolute(root, u32.!(superIdx));	// root never needs dispatch adapter
					}
					var name = if(WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT,
						      wasm.getMethodName(m), null);
					var mFuncIdx = u32.!(m.machIndex);
					var dinfo = superDispatch;
					if (superDispatch != DispatchInfo.Absolute(m, mFuncIdx)) {
						// New dispatch adapter needed
						dinfo = DispatchInfo.Relative(m, u32.!(wasm.dispatchAdapters.length));
						wasm.dispatchAdapters.put((root.receiver, root.sig, m.receiver, m.sig, mFuncIdx, m, int.!(sigIdx)));
						// The dispatch adapter is its own Wasm function
						if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
							var sb = StringBuilder.new().put3("Adding dispatch adapter for %s; sig idx=#%d entry %q", name, sigIdx, dinfo.render);
							prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
						}
					}
					dispTable.put(dinfo);
					if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
						var sb = StringBuilder.new().put3("Adding dispatch table entry for %s; func #%d entry %q", name, mFuncIdx, dinfo.render);
						prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
					}
					superDispatch = dinfo;
					superIdx = m.machIndex;
				}
			}
			wasm.dispatchTables.put(dispTable);
		}
		def numTables = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# tables = %d", numTables);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}

		// Now that we have figured out the adapters, we can emit code
		if (WasmComponent.includeSection.CODE) {
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Building code buffer ==========");
			var codegen = WasmGcCodeGen.new(context, wasm, rt, codebuf);
	                rt.recordCodeStart(codebuf.addr_end());
			if (wasm.allocateStubFuncIndex >= 0) { // add allocation stub body
				if (WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put1("Emitting allocation stub #%d", wasm.allocateStubFuncIndex);
					prog.ERROR.addError(null, null, "Code Section", sb.extract());
				}
				codegen.emitAllocationStub();
			}
			if (wasm.entryStubFuncIndex >= 0) {
				if (WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put1("Emitting entry stub #%d", wasm.entryStubFuncIndex);
					prog.ERROR.addError(null, null, "Code Section", sb.extract());
				}
				codegen.emitEntryStub(test);
			}
			for (i = wasm.numImports; i < methods.length; i++) {
				var m = methods[i];
				codegen.emitWasm(m, m.machIndex);
				if (WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put2("Emitting non-imported function %s #%d", wasm.getMethodName(m), m.machIndex);
					prog.ERROR.addError(null, null, "Code Section", sb.extract());
				}
			}

			var base = methods.length;
			for (j < wasm.indirectAdapterRequests.length) {
				var m = wasm.indirectAdapterRequests[j];
				var findex = wasm.getNextFuncIndex();
				wasm.indirectAdapterFor[m] = findex;
				if (WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put3("Emitting indirect adapter function #%d, indirect adapter %d, for method %s",
									  findex, j, wasm.getMethodName(m));
					prog.ERROR.addError(null, null, "Code Section", sb.extract());
				}
				codegen.emitIndirectAdapter(m);
				wasm.functionTable.put((m, u32.!(findex)));
			}

			for (j < wasm.dispatchAdapters.length) {
				var entry = wasm.dispatchAdapters[j];
				var meth = entry.5;
				var findex = wasm.getNextFuncIndex();
				wasm.dispatchAdapterFor[meth] = findex;
				if (WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put3("Emitting dispatch adapter function #%d, dispatch adapter %d, for method %s",
									  findex, j, wasm.getMethodName(meth));
					prog.ERROR.addError(null, null, "Code Section", sb.extract());
				}
				codegen.emitDispatchAdapter(meth);
				wasm.functionTable.put((meth, u32.!(findex)));
			}
	                rt.recordCodeEnd(codebuf.addr_end());
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Done building code buffer ==========");
		}

		// (2) Emit types
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.TYPE) {
			out.startSection(WasmSection.TYPE.code);
			out.put_uleb32(u32.!(wasm.gcTypeTable.typeGroups.length));
			wasm.gcTypeTable.emit(out);
			out.endSection();
		}

		// (3) Emit imports
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.IMPORT) {
			if (wasm.numImports > 0) {
				out.startSection(WasmSection.IMPORT.code);
				out.put_sleb32(wasm.numImports);
				if (WasmComponent.printSection.IMPORT) {
					var sb = StringBuilder.new().put1("========== Emitting %d imports ==========", wasm.numImports);
					prog.ERROR.addError(null, null, "Import Section", sb.extract());
				}
				for (i = 0; i < wasm.numImports; i++) {
					var m = methods[i];
					var compName = VstComponent.!(m.source.receiver).importName.image;
					var methName = m.source.importName.image;
					var sigidx = wasm.getSigIndex(m);
					out.importName(compName);
					out.importName(methName);
					out.putb(/*Function import*/0);
					out.put_uleb32(sigidx);
					if (WasmComponent.printSection.IMPORT) {
						var sb = StringBuilder.new().put3("Function sig #%d %s.%s", sigidx, compName, methName);
						prog.ERROR.addError(null, null, "Import Section", sb.extract());
					}
				}
				out.endSection();
				if (WasmComponent.printSection.IMPORT) {
					var sb = StringBuilder.new().put1("========== Done ==========", wasm.numImports);
					prog.ERROR.addError(null, null, "Import Section", sb.extract());
				}
			} else {
				if (WasmComponent.printSection.IMPORT)
					prog.ERROR.addError(null, null, "Import Section", "========== Not emitting (no imports) ==========");
			}
		}

		// (4) Emit function signature declarations
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.FUNCTION) {
			out.startSection(WasmSection.FUNCTION.code);

			var findex = 0;
			var nfoutput = wasm.numFunctions - wasm.numImports;
			if (WasmComponent.printSection.FUNCTION) {
				var sb = StringBuilder.new().put1("========== Emitting %d function signature indexes ==========", nfoutput);
				prog.ERROR.addError(null, null, "Function Section", sb.extract());
			}
			// Imports appear in a separate section, so are not part of this count.
			// Note that numFunctions does *not* correspond to methods.length, since
			// stubs and indirect adapters are not in the methods Vector.
			out.put_sleb32(nfoutput);

			// Stubs come first
			if (wasm.allocateStubFuncIndex >= 0) {  // add allocation stub
				out.put_sleb32(wasm.sigIndex_i_i);
				if (WasmComponent.printSection.FUNCTION) {
					var sb = StringBuilder.new().put3("Alloc function index %d (fn %d) sig index #%d",
									  findex++, wasm.allocateStubFuncIndex, wasm.sigIndex_i_i);
					prog.ERROR.addError(null, null, "Function Section", sb.extract());
				}
			}
			if (wasm.entryStubFuncIndex >= 0) {
				out.put_sleb32(wasm.sigIndex_entryStub);
				if (WasmComponent.printSection.FUNCTION) {
					var sb = StringBuilder.new().put3("Entry function index %d (fn %d) sig index #%d",
									  findex++, wasm.entryStubFuncIndex, wasm.sigIndex_entryStub);
					prog.ERROR.addError(null, null, "Function Section", sb.extract());
				}
			}
			// Non-imported functions come next
			for (i = wasm.numImports; i < methods.length; i++) {
				var m = methods[i];
				context.method = m;
				var sigidx = wasm.getSigIndex(m);
				out.put_uleb32(sigidx);
				if (WasmComponent.printSection.FUNCTION) {
					var sb = StringBuilder.new().put3("Function index %d sig index #%d method %s",
									  findex++, sigidx, wasm.getMethodName(m));
					prog.ERROR.addError(null, null, "Function Section", sb.extract());
				}
			}
			// Indirect adapters come next
			for (i < wasm.indirectAdapterRequests.length) {
				var m = wasm.indirectAdapterRequests[i];
				var index = wasm.addSig(AnyRef.TYPE, m.sig);
				out.put_uleb32(index - 1);
				if (WasmComponent.printSection.FUNCTION) {
					var sb = StringBuilder.new().put3("Indirect adapter index %d sig index #%d method %s",
									  findex++, index, wasm.getMethodName(m));
					prog.ERROR.addError(null, null, "Function Section", sb.extract());
				}
			}
			// Dispatch adapters come last
			for (i < wasm.dispatchAdapters.length) {
				var e = wasm.dispatchAdapters[i];
				var sigidx = e.6;
				out.put_uleb32(u32.!(sigidx - 1));
				if (WasmComponent.printSection.FUNCTION) {
					var sb = StringBuilder.new().put3("Dispatch adapter index %d sig index #%d method %s",
									  findex++, sigidx, wasm.getMethodName(e.5));
					prog.ERROR.addError(null, null, "Function Section", sb.extract());
				}
			}
			out.endSection();
			if (WasmComponent.printSection.FUNCTION)
				prog.ERROR.addError(null, null, "Function Section", "========== Done ==========");
		}

		// (5) Emit indirect function table and method indirect and dispatch tables
		//--------------------------------------------------------------------------------
		var table_length = u32.!(wasm.functionTable.length + 1);
		var numOtherTables = wasm.tables.length;
		if (WasmComponent.includeSection.TABLE) {
			if ((table_length > 1 || numOtherTables > 0)) {
				var ntables = numOtherTables + 1;
				if (WasmComponent.printSection.TABLE) {
					var sb = StringBuilder.new().put1("========== Emitting %d tables ==========", ntables);
					prog.ERROR.addError(null, null, "Table Section", sb.extract());
				}
				var tabnum = 0;
				out.startSection(WasmSection.TABLE.code);
				out.putb(ntables);  // number of tables
				// First table (overall indirect function table)
				out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
				out.putb(1);	// flags = contains maximum
				out.put_uleb32(table_length);  // initial table length
				out.put_uleb32(table_length);  // maximum table length
				if (WasmComponent.printSection.TABLE) {
					var sb = StringBuilder.new().put2("Indirect function table (#%d); num entries %d", tabnum++, table_length);
					prog.ERROR.addError(null, null, "Table Section", sb.extract());
				}
				// Remaining tables, in order
				// The two kinds are mixed (sigh)
				for (tabidx < wasm.tables.length) {
					var wtabnum = tabidx + 1;
					var tab = wasm.tables[tabidx];
					match (tab) {
						Dispatch(tabnum, rootRcvr, rootSig, sigIndex, entries) => {
							if (WasmComponent.printSection.TABLE) {
								var sb = StringBuilder.new().put1("%q", tab.render);
								prog.ERROR.addError(null, null, "Table Section", sb.extract());
							}
							var count = entries.length;
							if (count == 0) {
								out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
								out.putb(1);	// flags = contains maximum
								out.put_uleb32(0);  // initial table length
								out.put_uleb32(0);  // maximum table length
								continue;
							}

							var fsig = wasm.getSig(rootRcvr, rootSig);
							var wft = wasm.gcTypeTable.addSignature(fsig);
							var wvt = WasmValueType.RefNull(wft);
							wvt.put(out);
							out.putb(1);	// flags = contains maximum
							out.put_uleb32(u32.!(count));
							out.put_uleb32(u32.!(count));
						}
						Indirect(tabnum, rootRcvr, rootSig, entries) => {
							if (WasmComponent.printSection.TABLE) {
								var sb = StringBuilder.new().put1("%q", tab.render);
								prog.ERROR.addError(null, null, "Table Section", sb.extract());
							}

							var sigidx = wasm.addSig(AnyRef.TYPE, rootSig);
							var fsig = wasm.getSig(AnyRef.TYPE, rootSig);
							var wft = wasm.gcTypeTable.addSignature(fsig);
							var wvt = WasmValueType.RefNull(wft);

							var count = entries.length;
							if (count == 0) {
								// an empty table??
								out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
								out.putb(1);	// flags = contains maximum
								out.put_uleb32(0);  // initial table length
								out.put_uleb32(0);  // maximum table length
								continue;
							}
							wvt.put(out);
							out.putb(1);	// flags = contains maximum
							out.put_uleb32(u32.!(count));
							out.put_uleb32(u32.!(count));
						}
						ReserveDispatch, ReserveIndirect => ; // reservations already dealt with
					}
					
				}
				out.endSection();
				if (WasmComponent.printSection.TABLE)
					prog.ERROR.addError(null, null, "Table Section", "========== Done ==========");
			} else {
				if (WasmComponent.printSection.TABLE)
					prog.ERROR.addError(null, null, "Table Section", "========== Not emitted (no tables) ==========");
			}
		}
			
		// (6) Emit memory section
		//--------------------------------------------------------------------------------
		var hasMemorySection = false;
		if (WasmComponent.includeSection.MEMORY) {
			if (m.allocates && rt.heapSize == 0) {
				rt.heapSize = 65536;	// min of one page to allocate into
			}
			var totalSize = rt.heapSize + rt.shadowStackSize;
			if (totalSize > 0) {
				hasMemorySection = true;
				if (WasmComponent.printSection.MEMORY)
					prog.ERROR.addError(null, null, "Memory Section", "========== Emitting ==========");
				out.startSection(WasmSection.MEMORY.code);
				out.putb(1);	// 1 memory
				// Compute the maximum accessible data address, and from that the pages needed
				var maxDataAddr = u32.!(rt.heapSize + rt.shadowStackSize);
				var pages = (maxDataAddr + pageSize - 1u) / pageSize;
				var flags = 1;
				if (pageSize != 65536) flags |= 1 << 3;		// custom page size
				out.putb(flags);				// flags = contains maximum
				out.put_uleb32(pages);				// initial memory size
				out.put_uleb32(pages);				// maximum memory size
				if (pageSize != 65536) {
					out.put_uleb32(u32.!(Ints.log(pageSize))); // page size log
				}
				if (WasmComponent.printSection.MEMORY) {
					var sb = StringBuilder.new().put2("Size = %d (0x%x) bytes", maxDataAddr, maxDataAddr)
								    .put2(", %d (0x%x) pages", pages, pages)
								    .put2(", page size %d (0x%x) bytes", pageSize, pageSize);
					prog.ERROR.addError(null, null, "Memory Section", sb.extract());
					prog.ERROR.addError(null, null, "Memory Section", "========== Done ==========");
				}
				out.endSection();
			} else {
				if (WasmComponent.printSection.MEMORY)
					prog.ERROR.addError(null, null, "Memory Section", "========== Not emitted (no allocation, etc.) ==========");
			}
		}

		// (7) Emit the export section
		//--------------------------------------------------------------------------------
		var mainMeth = prog.getMain();
		var numExports = 0;		  // default exports: main and maybe memory
		var mainIndex: int;
		var mainName: string;
		if (mainMeth != null) {
			mainIndex = mainMeth.asMethod().machIndex;
			mainName = CLOptions.MAIN_EXPORT.get();

			if (wasm.entryStubFuncIndex >= 0) {
				mainIndex = wasm.entryStubFuncIndex;
				mainName = if(test, mainName, CLOptions.ENTRY_EXPORT.get());
			}
			numExports = 1;
		}
		if (CLOptions.WASM_EXPORT_MEM.val && hasMemorySection) numExports++;
		for (i < prog.ir.roots.length) {
			var r = prog.ir.roots[i];
			if (r.name != null) numExports++;
		}

		if (WasmComponent.includeSection.EXPORT) {
			if (numExports > 0) {
				if (WasmComponent.printSection.EXPORT) {
					var sb = StringBuilder.new().put1("========== Emitting %d exports ==========", numExports);
					prog.ERROR.addError(null, null, "Export Section", sb.extract());
				}
				var exportIndex = 0;
				out.startSection(WasmSection.EXPORT.code);
				out.putb(numExports);
				if (mainMeth != null) {
					// export main
					out.str(mainName);
					out.putb(WasmExternal.FUNCTION);
					out.put_sleb32(mainIndex);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put3("Export #%d: function %s, function #%d (main)", exportIndex++, mainName, mainIndex);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				// export memory
				if (CLOptions.WASM_EXPORT_MEM.val && hasMemorySection) {
					out.str("memory");
					out.putb(WasmExternal.MEMORY);
					out.put_uleb32(0);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put1("Export #%d: memory 0", exportIndex++);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				// export the rest of exported functions
				for (i < prog.ir.roots.length) {
					var r = prog.ir.roots[i];
					if (r.name == null) continue;
					out.importName(r.name);
					out.putb(WasmExternal.FUNCTION);
					var findex = r.spec.asMethod().machIndex;
					out.put_sleb32(findex);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put3("Export #%d: function %s, function #%d", exportIndex++, r.name, findex);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				if (WasmComponent.printSection.EXPORT)
					prog.ERROR.addError(null, null, "Export Section", "========== Done ==========");
				out.endSection();
			}
		}

		// (8) Emit the function table entries
		// This includes indirect and dispatch adapter tables for each class that needs them
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.ELEMENT) {
			if ((table_length > 1 || numOtherTables > 0)) {
				var ntables = u32.!(numOtherTables + 1);
				if (WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put1("========== Emitting %d element groups ==========", ntables);
					prog.ERROR.addError(null, null, "Element Section", sb.extract());
				}
				out.startSection(WasmSection.ELEMENT.code);
				out.put_uleb32(ntables);
				// Indirect function table
	 			out.putb(0);  // Elements kind is "Active Zero: start offset is an expression, table number is 0"
				// start init expr for base index of elements
				out.putb(WasmOp.I32_CONST.opcode);
				out.putb(1);  // start index of elements; 0 is reserved for null function
				out.putb(WasmOp.END.opcode);
				// end init expr
				// count of entries, followed by their values (function numbers)
				if (WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put1("Indirect function table (#0); # entries %d (including null first slot)", table_length);
					prog.ERROR.addError(null, null, "Element Section", sb.extract());
				}
				out.put_uleb32(table_length-1);
				for (i < wasm.functionTable.length) {
					var entry = wasm.functionTable[i];
					out.put_uleb32(entry.1);
					if (WasmComponent.printSection.ELEMENT) {
						var sb = StringBuilder.new().put3("Indirect function element %d function %d method %s",
										  i, entry.1, wasm.getMethodName(entry.0));
						prog.ERROR.addError(null, null, "Element Section", sb.extract());
					}
				}
				for (tabidx < wasm.tables.length) {
					var tab = wasm.tables[tabidx];
					var wtabnum = tabidx + 1;
					match (tab) {
						Dispatch(tabnum, rootRcvr, rootSig, sigIndex, entries) => {
							var fsig = wasm.getSig(rootRcvr, rootSig);
							var wft = wasm.gcTypeTable.addSignature(fsig);
							var wvt = WasmValueType.RefNull(wft);
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put2("%q type %q", tab.render, wvt.render);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							out.putb(6);  // Elements kind is "ActiveExpr: start offset is an expression, table number is explicit"
							out.put_uleb32(tabnum);  // table number
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(0);
							out.putb(WasmOp.END.opcode);
							wvt.put(out);
							out.put_uleb32(u32.!(entries.length));  // number of entries
							for (j = start; j < entries.length; ++j) {
								var entry = entries[j];
								var meth: IrMethod;
								var adapterFunc: int;
								match (entry) {
									Abstract(m) => {
										meth = m; adapterFunc = -1;
										// null function pointer
										out.putb(WasmOp.REF_NULL.opcode);
										wvt.put(out);
										out.putb(WasmOp.END.opcode);
									}
									Absolute(m, funcNum) => {
										meth = m; adapterFunc = int.!(funcNum);
										out.putb(WasmOp.REF_FUNC.opcode);
										out.put_uleb32(funcNum);
										out.putb(WasmOp.END.opcode);
									}
									Relative(m, adapterIndex) => {
										meth = m;
										var funcNum = wasm.dispatchAdapterBase + adapterIndex;
										adapterFunc = int.!(funcNum);
										out.putb(WasmOp.REF_FUNC.opcode);
										out.put_uleb32(funcNum);
										out.putb(WasmOp.END.opcode);
									}
								}
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Table %d entry %d %q", wtabnum, j, entry.render);
									sb.put1(" (%s)", wasm.getMethodName(meth));
									if (adapterFunc >= 0) sb.put1(" function %d", adapterFunc);
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
						Indirect(tabnum, rootRcvr, rootSig, entries) => {
							// Indirect function table
				 			out.putb(2);  // Elements kind is "Active Index: start offset is an expression, table number is explicit"
							// Table number
							out.put_uleb32(tabnum);
							// start init expr for base index of elements
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(0);  // start index of elements: 0
							out.putb(WasmOp.END.opcode);
							// end init expr
							out.putb(0);  // element kind: 0
							// count of entries, followed by their values (function numbers)
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put1("%q", tab.render);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							out.put_uleb32(u32.!(entries.length));
							for (j < entries.length) {
								out.put_uleb32(u32.!(entries[j].1));
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Table %d entry %d function %d",
													  wtabnum, j, entries[j].1);
									sb.put1(" (%s)", wasm.getMethodName(entries[j].0));
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
						ReserveDispatch, ReserveIndirect => ; // reservations already dealt with
					}
				}
				if (WasmComponent.printSection.ELEMENT)
					prog.ERROR.addError(null, null, "Element Section", "========== Done ==========");
				out.endSection();
			} else {
				if (WasmComponent.printSection.ELEMENT)
					prog.ERROR.addError(null, null, "Element Section", "========== Not emitted (no elements) ==========");
			}
		}

		// (9) Emit the function bodies
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.CODE) {
			var numBodies = wasm.numFunctions - wasm.numImports;
			if (WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put1("========== Emitting %d code bodies ==========", numBodies);
				prog.ERROR.addError(null, null, "Code Section", sb.extract());
			}
			out.startSection(WasmSection.CODE.code);
			out.put_sleb32(wasm.numFunctions - wasm.numImports);
			out.putmd(codebuf);
			out.endSection();
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Done ==========");
		}

		// (9) Emit the data section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.DATA && false) {	// turn off for now
			out.startSection(WasmSection.DATA.code);
			out.putb(1); // 1 data entry
			out.putb(0); // linear memory #0
			out.putb(WasmOp.I32_CONST.opcode);
// EBM		out.put_sleb32(int.view(dataStartAddr));  // linear memory offset
			out.putb(WasmOp.END.opcode);
			var data_sizepos = out.skip_leb32(); // data size
			var data_start = out.pos;
// EBM		out.startAddr = int.view(dataStartAddr) - out.end();
			// Encode meta region
	                m.layoutMeta(out);
	                // Encode runtime region
	                m.layoutRuntime(out);
			// Encode data region
	                rt.recordDataStart(out.addr_end());
	                m.layoutData(out);
	                rt.recordDataEnd(out.addr_end());
			// Add the heap pointers after the initialized data. XXX: use WASM globals.
			if (m.allocates || rt.shadowStackSize > 0) rt.addHeapPointers(out);

			WasmCommon.patchSize(out, data_sizepos, out.atEnd().pos - data_start);
			out.endSection();
		}

		out.patch(patchAddress(wasm.mach, _, _, _));

		// (10) Emit the name section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.NAME && CLOptions.SYMBOLS.val) {
			out.startSection(WasmSection.UNKNOWN.code);
			out.str("name");
			// output function name subsection
			out.putb(1); // names of functions
			var funcname_sizepos = out.skip_leb32();
			var funcname_start = out.pos;
			var count = u32.!(methods.length);
			if (m.allocates) count++;
			if (wasm.entryStubFuncIndex >= 0) count++;
			out.put_uleb32(count);
			if (wasm.allocateStubFuncIndex >= 0) {
				out.put_uleb32(u32.!(wasm.allocateStubFuncIndex));
				out.str(".alloc");
			}
			if (wasm.entryStubFuncIndex >= 0) {
				out.put_uleb32(u32.!(wasm.entryStubFuncIndex));
				out.str(".entry");
			}

			var namebuf = StringBuilder.new();
			for (i < methods.length) {
				var m = methods[i];
				out.put_uleb32(u32.!(m.machIndex));
				emitMethodName(out, m, namebuf);
			}
			WasmCommon.patchSize(out, funcname_sizepos, out.atEnd().pos - funcname_start);
			out.endSection();
		}

		// Dump the bytes to the file
		var fileName = context.compiler.getOutputFileName(prog.name(), "wasm");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) {
			prog.ERROR.OutputError(fileName);
			return null;
		}
		System.write(fd, out.alias());
		System.fileClose(fd);
		return out;
	}
	def layoutAllRecordsAndFuncs(m: MachProgram) {
		Vectors.drain(m.recordQueue, 0, layoutRecord(m, _));
	}
	private def layoutRecord(m: MachProgram, r: Record) {
		for (v in r.values) layoutVal(m, v);
	}
	private def layoutVal(m: MachProgram, val: Val) {
		match (val) {
			x: Record => addrOfRecord(m, x);
			x: FuncVal => addrOfMethod(m, x.memberRef.asMethod());
			// EBM: Ben says Closure should be normalized away
			x: Closure => { layoutVal(m, x.val); addrOfMethod(m, x.memberRef.asMethod());  }
			x: BoxVal => for (e in x.values) layoutVal(m, e);
			// There are a number of other cases, which do not need space.
		}
	}
	def addrOfRecord(m: MachProgram, r: Record) -> Address<Record> {
		var addr = m.recordMap[r];
		if (addr == null) {
			// allocate required globals
			// components: one for each field
			// classes/arrays: one for a ref to the object
			addr = GLOBALS_REGION.allocate(r, getObjectSize(m, r.rtype, r));
			m.recordMap[r] = addr;
		}
		return addr;
	}
	def getObjectSize(m: MachProgram, t: Type, r: Record) -> int {
		var size: int;
		match (t) {
			x: ClassType => {
				var ic = m.prog.ir.getIrClass(t);
				if (ic == null) m.fail(Strings.format2("getObjectSize(#%d): class %q has no IrClass", r.id, t.render));
				else if (V3.isComponent(t)) size = ic.fields.length;
				else size = 1;
			}
			x: ArrayType => size = 1;  // a ref
			_ => return m.unexpectedType(t, 0);
		}
		return size;
	}
	def addrOfMethod(mp: MachProgram, m: IrMethod) -> Address<IrMethod> {
		var a = mp.methodMap[m];
		if (a == null) {
			// Actual address is assigned later in addIrMethodAddr
			mp.methodMap[m] = a = Address.new(FUNCTIONS_REGION, m);
		}
		return a;
	}

	def patchAddress(mach: MachProgram, w: MachDataWriter, a: Addr, posAddr: int) {
		var abs = mach.absolute(a);
		if (CLOptions.PRINT_BIN.get()) {
			TerminalBuffer.new()
				.puts("patch-address @+")
				.putd(w.pos)
				.puts(" <- ")
				.putcv(a, null)
				.puts(" = ")
				.putx(abs)
				.outln();
		}
		// TODO,XXX: address immediates are in i32.const, which is a signed LEB.
		w.overwrite_sleb32(abs);
	}
	def emitTestWrappers(context: SsaContext, rt: MachRuntime, w: DataWriter, e: ExecuteTestCase) {
		var prog = context.prog;
		var fileName = context.compiler.getOutputFileName(prog.name(), "expect.js");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		var buf = StringBuilder.new();
		buf.put1("// %s\n", prog.name());

		buf.puts("var globalTestRuns = [\n");

		for (r = e.runs; r != null; r = r.tail) {
			var run = r.head;
			buf.puts("\t[");
			putJsValue(buf, run.expected);
			buf.puts(", [");
			for (i = run.input; i != null; i = i.tail) {
				putJsValue(buf, i.head);
				if (i.tail != null) buf.csp();
			}
			buf.puts("]],\n");
		}

		buf.puts("];\n");

		System.fileWriteK(fd, buf.buf, 0, buf.length);
		System.fileClose(fd);

		// emit Wasm spec test wrapper
		fileName = context.compiler.getOutputFileName(prog.name(), "bin.wast");
		fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		buf.reset();
		buf.puts("(module binary\n");
		for (i < w.end()) {
			if ((i & 31) == 0) buf.puts(" \"");
			buf.puts("\\");
			buf.putx_8(w.data[i]);
			if ((i & 31) == 31 || (i == w.end() - 1)) buf.puts("\"").ln();
		}
		buf.puts("\n)\n");
		for (r = e.runs; r != null; r = r.tail) {
			var run = r.head;
			if (Exception.?(run.expected)) buf.puts("(assert_trap ");
			else buf.puts("(assert_return ");
			buf.puts("(invoke \"main\" ");
			for (i = run.input; i != null; i = i.tail) {
				putWasmValue(buf, i.head);
			}
			buf.puts(")\n");
			if (Exception.?(run.expected)) {
				var ex = Exception.!(run.expected);
				if (Strings.equal(V3Exception.DivideByZero, ex.error)) buf.puts("\"integer divide by zero\"");
				else buf.puts("\"unreachable\"");
			}
			else putWasmValue(buf, run.expected);
			buf.puts(")\n");
		}

		System.fileWriteK(fd, buf.buf, 0, buf.length);
		System.fileClose(fd);
	}
	def putWasmValue(buf: StringBuilder, r: Result) -> StringBuilder {
		match (r) {
			x: Box<int> => return buf.puts("(i32.const 0x").putx(x.val).putc(')');
			x: Box<bool> => return buf.puts("(i32.const 0x").putx(if(x.val, 1, 0)).putc(')');
			null => return buf.puts("(i32.const 0x0)");
		}
		return buf;
	}
	def putJsValue(buf: StringBuilder, r: Result) -> StringBuilder {
		match (r) {
			x: Box<int> => return buf.putd(x.val);
			x: Box<bool> => return buf.putd(if(x.val, 1, 0));
			x: Exception => return buf.puts("WebAssembly.RuntimeError");
			null => return buf.puts("0");
		}
		return buf;
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	def getRuntime(prog: Program) -> MachRuntime {
		return MachProgram.!(prog.tprog).runtime;
	}
	def emitMethodName(w: MachDataWriter, m: IrMethod, namebuf: StringBuilder) {
		namebuf.reset();
		m.renderLong(namebuf);
		w.put_uleb32(u32.!(namebuf.length));
		w.putk(namebuf.buf, 0, namebuf.length);
	}
        def emitEngineScript(cmd: string, compiler: Compiler, prog: Program) {
		var programName = prog.name();
		var fileName = compiler.getOutputFileName(programName, null);
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		compiler.emitBashScriptHeader(fd);
		System.write(fd, cmd);
                System.write(fd, " $DIR/");
		System.write(fd, programName);
		System.write(fd, ".wasm");
		System.write(fd, " \"$@\"\n");
		System.fileClose(fd);
		compiler.makeExecutable(fileName);
        }
}

// class WasmGcProgram(prog: Program, context: SsaContext, test: bool) {
class WasmGcProgram(mach: MachProgram, context: SsaContext, test: bool) {
	var gcTypeTable: WasmGcTypeTable;

	//
	// EBM: From WasmProgram; revisit
	//
	// Maps from a method to its index in the function table
	def functionTable = Vector<(IrMethod, u32)>.new();

	// Indicates the indirect adapter function number for a given method
	def indirectAdapterFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);
	def indirectAdapterRequests = Vector<IrMethod>.new();
	// Indirect adapters in function order
	def indirectAdapters = Vector<IrMethod>.new();

	// Maps from method tables to corresponding indirection table (Wasm table number)
	def indirectTableFor = HashMap<IrMtable,int>.new(IrItem.uid, IrMtable.==);
	def indirectTableRequests = Vector<IrMtable>.new();

	// The 1st Type,Signature is root class Type,Signature, 2nd is subclass Type,Signature, last three
	// are function number and IrMethod for the subclass method, and signature type index of the root;
	// the dispatch adapter function number is the position in the vector plus a base determined later
	def dispatchAdapters = Vector<(Type, Signature, Type, Signature, u32, IrMethod, int)>.new();
	// Indicates the dispatch adapter function number for a given method
	def dispatchAdapterFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);
	def dispatchAdapterRequests = Vector<IrMethod>.new();
	var dispatchAdapterBase: u32 = 0;  // function index of first dispatch adapter

	// Maps from method table to corresponding dispatch tables (Wasm table number)
	def dispatchTableFor = HashMap<IrMtable,int>.new(IrItem.uid, IrMtable.==);
	def dispatchTableRequests = Vector<IrMtable>.new();
	// The entries of each dispatch table
	def dispatchTables = Vector<Vector<DispatchInfo>>.new();

	// method tables that need to be emitted
	def mtables = Vector<IrMtable>.new();

	// this accumulates the tables in the order they need to be output
	def tables = Vector<TableInfo>.new();

	var sigIndex_i_i = -1;
	var sigIndex_entryStub = -1;

	// known function indices
	var entryStubFuncIndex = -1;
	var allocateStubFuncIndex = -1;

	var numImports = 0;
	var numFunctions = 0;
	var containsCallIndirect = false;
	//
	// End from WasmProgram
	//

	new() {
		gcTypeTable = WasmGcTypeTable.new(wasmGcType, mach.prog.ERROR);
	}

	def requestIndirectAdapter(m: IrMethod) {
		if (!indirectAdapterFor.has(m)) {
			indirectAdapterFor[m] = -1;
			indirectAdapterRequests.put(m);
			addSig(AnyRef.TYPE, m.sig);
		}
	}
	def requestDispatchAdapter(m: IrMethod) {
		if (!dispatchAdapterFor.has(m)) {
			dispatchAdapterFor[m] = -1;
			dispatchAdapterRequests.put(m);
		}
	}
	def requestIndirectTable(m: IrMtable) {
		if (!indirectTableFor.has(m)) {
			indirectTableFor[m] = -1;
			indirectTableRequests.put(m);
		}
	}
	def requestDispatchTable(m: IrMtable) {
		if (!dispatchTableFor.has(m)) {
			dispatchTableFor[m] = -1;
			dispatchTableRequests.put(m);
		}
	}

	// make this a *little* more abstract
	def getNextFuncIndex() -> int {
		return numFunctions++;
	}
	def getMtableNumber(mtable: IrMtable) -> int {
		if (mtable == null) return -1;
		var mtaddr = mach.mtableMap[mtable];
		if (mtaddr == null) {
			mtaddr = Addr.new(null, null, 0);
			mach.mtableMap[mtable] = mtaddr;
		}
		if (mtaddr.absolute < 0) {
			mtables.put(mtable);
			mtaddr.absolute = mtables.length;
		}
		return mtaddr.absolute;
	}
	def getIndirectTableNumber(mtable: IrMtable) -> int {
		getMtableNumber(mtable);  // insure recorded
		if (!indirectTableFor.has(mtable)) {
			tables.put(TableInfo.ReserveIndirect(mtable));
			var num = tables.length;
			indirectTableFor[mtable] = num;
			return num;
		}
		return indirectTableFor[mtable];
	}
	def getDispatchTableNumber(mtable: IrMtable) -> int {
		getMtableNumber(mtable);  // insure recorded
		if (!dispatchTableFor.has(mtable)) {
			tables.put(TableInfo.ReserveDispatch(mtable));
			var num = tables.length;
			dispatchTableFor[mtable] = num;
			return num;
		}
		return dispatchTableFor[mtable];
	}
	def wasmGcType(t: Type) -> WasmValueType {
		return gcTypeTable.getValueTypeFor(t);
	}

	def getSig(receiver: Type, sig: Signature) -> Signature {
//		var sb = StringBuilder.new().put2("receiver=%q  sig=%q", receiver.render, sig.funcType().render);
//		mach.prog.ERROR.addError(null, null, "getSig", sb.extract());
		if (receiver != Void.TYPE && !V3.isComponent(receiver))
			sig = Signature.new(null, Arrays.prepend(receiver, sig.paramTypes), sig.returnTypes);
		return sig;
	}
	def addSig(receiver: Type, sig: Signature) -> u32 {
		var wft = gcTypeTable.addSignature(getSig(receiver, sig));
		return u32.!(wft.index);
	}
	def getSigIndex(m: IrMethod) -> u32 {
		var sig = getSig(m.receiver, m.sig);
		var wft = gcTypeTable.addSignature(sig);
		var index: u32 = if(wft == null, 0, wft.index);
		if (index == 0) context.fail1("method signature not found: %q", sig.funcType().render);
		return u32.!(index - 1);
	}
	def getMethodName(m: IrMethod) -> string {
		var name = "?";
		var ms = m.source;
		if (ms != null) {
			var sig = getSig(m.receiver, m.sig);
			var wht = gcTypeTable.addSignature(sig);
			var mn = ms.name();
			var rt = m.receiver;
			var rn = getClassName(rt);
			name = StringBuilder.new().put2("%s.%s", rn, mn).extract();
		}
		return name;
	}
	def getClassName(ctype: Type) -> string {
		return if(ClassType.?(ctype),ClassType.!(ctype).classDecl.name(),ctype.typeCon.name);
	}
	def addIrMethodAddr(m: IrItem, addr: Address<IrMethod>) {
		var m = addr.val;
		var name: string = if(WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT,
				      getMethodName(m), null);
		if (m.machIndex < 0) context.fail1("method not assigned an index: %q", m.renderLong);
//		var tableEntry = u32.!(m.machIndex);

		// allocate indirect call wrapper for method (first param void)
		var index = addSig(AnyRef.TYPE, m.sig);
		indirectAdapterFor[m] = functionTable.length + 1; // + 1 to skip null entry at beginning
		indirectAdapters.put(m);
		// the indirect adapter is its own Wasm function
		var tableEntry = u32.!(getNextFuncIndex());
		if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
			var sb = StringBuilder.new().put3("Adding indirect adapter for %s; sig idx=#%d entry #%d", name, index, tableEntry);
			mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
		}
		// An IrMethod's "address" is its index into the function table
		addr.absolute = int.!(tableEntry);
		// Record the function to be added to the Wasm table of functions for indirect calls
		if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
			var sb = StringBuilder.new().put2("Adding function %s; entry #%d", name, tableEntry);
			mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
		}
		functionTable.put((m, tableEntry));
	}
	def addDispatchedMethodAddr(rootRcvr: Type, rootSig: Signature,
				    superInfo: DispatchInfo, superIdx: i32,
	                            table: Vector<DispatchInfo>,
				    addr: Address<IrMethod>) -> DispatchInfo {
		// rootRcvr and rootSig give the root methods class and signature (in case we need
		// to add a dispatchAdapters entry).
		// superInfo gives info on the superclass's dispatch method (so it can be re-used
		// if the subclass version of the method is the same).
		// superIdx is the index of the superclass's version of the method.  If this method's
		// index is different, then it needs a new dispatch method.
		// table is the vector of (method,dispatch function index) pairs we are building.
		// addr is the Address of the IrMethod being added (it carries the method with it).
		// A negative return value is the negative of the relative number of a dispatch adapter,
		// a non-negative return value is the function index of a root method
		var m = addr.val;
		var name = if(WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT,
			      getMethodName(m), null);
		var mFuncIdx = u32.!(m.machIndex);
		var dinfo = superInfo;
		if (superInfo != DispatchInfo.Absolute(m, mFuncIdx)) {
			// New dispatch adapter needed
			var sigIdx = addSig(rootRcvr, rootSig);	// make sure signature is present
			dinfo = DispatchInfo.Relative(m, u32.!(dispatchAdapters.length));
			dispatchAdapters.put((rootRcvr, rootSig, m.receiver, m.sig, mFuncIdx, m, int.!(sigIdx)));
			// the dispatch adapter is its own Wasm function
			if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
				var sb = StringBuilder.new().put3("Adding dispatch adapter for %s; sig idx=#%d entry %q", name, sigIdx, dinfo.render);
				mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
			}
		}
		addr.absolute = int.!(mFuncIdx);
		table.put(dinfo);
		if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
			var sb = StringBuilder.new().put3("Adding dispatch table entry for %s; func #%d entry %q", name, mFuncIdx, dinfo.render);
			mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
		}
		return dinfo;
	}
	def addIrMethods() -> Vector<IrMethod> {
		var methods = mach.prog.ir.methods;
		// We place imported function first, locally defined ones later;
		// any stubs will be emitted in between.  Note that position in
		// the methods Vector does not always correspond to Wasm function number.
		var sorted = Array<IrMethod>.new(methods.length);
		var j = 0;

		// Add all imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source == null || m.source.importName == null) continue;
			addMethod(m);
			sorted[j++] = m;
		}
		numImports = j;
		numFunctions = numImports;

		// Add the allocation stub if necessary
		if (mach.allocates) {
			var sig = FuncType.!(Function.newType(Int.TYPE, Int.TYPE)).sig();
			sigIndex_i_i = int.!(addSig(Void.TYPE, sig));
			allocateStubFuncIndex = getNextFuncIndex();
		}
		// Add the entry stub if {RiRuntime.init} or {RiRuntime.exit} exists.
		var ri_init = mach.runtime.getRiInit();
		var ri_exit = mach.runtime.getRiExit();
		if (ri_init != null || ri_exit != null) {
			var main = mach.prog.getMain();
			var mainMeth = if(main != null, main.asMethod());
			var mainSig = if(mainMeth != null, mainMeth.sig);

			if (test) {
				// no inputs; outputs are arguments to Wasm main, prepared by the testing function
				sigIndex_entryStub = int.!(addSig(Void.TYPE, mainSig));
			} else {
				// inputs are what ri_init needs (none if it is not called)
				var params: Array<Type> = if(ri_init != null, ri_init.sig.paramTypes, TypeUtil.NO_TYPES);
				// outputs are what ri_exit returns if ri_exit is used, otherwise an int success code
				var results: Array<Type> = if(ri_exit != null, ri_exit.sig.returnTypes, [Int.TYPE]);
				var sig = Signature.new(null, params, results);
				sigIndex_entryStub = int.!(addSig(Void.TYPE, sig));
			}
			entryStubFuncIndex = getNextFuncIndex();
			if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
				var sb = StringBuilder.new().put2("Adding entry stub; sig idx=#%d entry #%d", sigIndex_entryStub, entryStubFuncIndex);
				mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
			}
		}

		// Add all non-imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source != null && m.source.importName != null) continue;
			addMethod(m);
			sorted[j++] = m;
		}

		Arrays.copyInto(sorted, methods.array, 0);  // update the IrModule's method vector.
		return methods;
	}
	def addMethod(m: IrMethod) {
		var sigIdx = addSig(m.ssa.params[0].vtype, m.sig);
		m.machIndex = getNextFuncIndex();
		if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
			var name = getMethodName(m);
			var sb = StringBuilder.new().put3("Adding method %s; sig idx=#%d entry #%d", name, sigIdx, m.machIndex);
			mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
		}
	}
	def processMtables() {
		for (mtIndex < mtables.length) {
			var mtable = mtables[mtIndex];
			if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.ELEMENT) {
				var sb = StringBuilder.new().put1("Processing method table for %q", mtable.render);
				mach.prog.ERROR.addError(null, null, "Function/Table/Element Section", sb.extract());
			}
			
			var root: IrMethod = mtable.root;
			var superIdx = root.machIndex;
			var superDispatch: DispatchInfo;
			if (superIdx < 0) {
				superDispatch = DispatchInfo.Abstract(mtable.root);
			} else {
				var superDispatch = DispatchInfo.Absolute(mtable.root, u32.!(superIdx));
			}
			var dispTable = Vector<DispatchInfo>.new();
			var needIndirectTable = indirectTableFor.has(mtable);
			if (needIndirectTable && (WasmComponent.printSection.FUNCTION ||
						  WasmComponent.printSection.TABLE ||
						  WasmComponent.printSection.CODE)) {
				var sb = StringBuilder.new().put2("Adding method indirect table %d for method table for %q",
								  indirectTableFor[mtable], mtable.render);
				mach.prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
			var indirectTable: Vector<(IrMethod, int)> = if(needIndirectTable,Vector<(IrMethod, int)>.new(),null);
			for (m in mtable.table) {
				if (m != null) {
					if (root == null) {
						root = m;
						superIdx = root.machIndex;
						superDispatch = DispatchInfo.Absolute(root, u32.!(superIdx));	// root never needs dispatch adapter
					}
					superDispatch =
						addDispatchedMethodAddr(root.receiver, root.sig, superDispatch,
									superIdx, dispTable, mach.addrOfMethod(m));
					superIdx = m.machIndex;

					if (needIndirectTable) {
						if (!indirectAdapterFor.has(m)) {
							var index = addSig(AnyRef.TYPE, m.sig);
							var tableEntry = getNextFuncIndex();
							indirectAdapterFor[m] = tableEntry;
							indirectAdapters.put(m);
							if (WasmComponent.printSection.FUNCTION ||
							    WasmComponent.printSection.TABLE ||
							    WasmComponent.printSection.CODE) {
								var sb = StringBuilder.new().put3("Adding method indirect adapter %d for method %d sig %d",
												  tableEntry, m.machIndex, index);
								mach.prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
							}
						}
						if (WasmComponent.printSection.FUNCTION ||
						    WasmComponent.printSection.TABLE ||
						    WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put3("Method indirect table %d entry %d is function %d",
											  indirectTableFor[mtable], indirectTable.length,
											  indirectAdapterFor[m]);
							mach.prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
						}
						indirectTable.put((m, indirectAdapterFor[m]));
					}
				}
			}

			if (root != null && dispatchTableFor.has(mtable)) {
				var tableNumber = u32.!(dispatchTableFor[mtable]);
				// show association of table number with the mtable
				if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.TABLE ||
				    WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put2("Dispatch table number is %d for method table for %q", tableNumber, mtable.render);
					mach.prog.ERROR.addError(null, null, "Function/Table/Element Section", sb.extract());
				}
				// insert a dispatch table
				var sigIdx = addSig(root.receiver, root.sig);	// make sure signature is present
				var tinfo = TableInfo.Dispatch(tableNumber, root.receiver, root.sig, int.!(sigIdx), dispTable);
				var index = int.!(tableNumber - 1);
				var oldEntry = tables[index];
				match (oldEntry) {
					ReserveDispatch(mt) => {
						if (mt != mtable) {
							var sb = StringBuilder.new()
									      .put2("expected mtable for %q but have mtable for %q",
										    mtable.render, mt.render);
							context.fail(sb.extract());
						}
					}
					_ => context.fail1("unexpected table info %q", oldEntry.render);
				}
				tables[index] = tinfo;
			}
			if (needIndirectTable) {
				var tableNumber = u32.!(indirectTableFor[mtable]);
				// show association of table number with the mtable
				if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.TABLE ||
				    WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put2("Indirect table number is %d for method table for %q", tableNumber, mtable.render);
					mach.prog.ERROR.addError(null, null, "Function/Table/Element Section", sb.extract());
				}
				// insert an indirect table
				var tinfo = TableInfo.Indirect(tableNumber, root.receiver, root.sig, indirectTable);
				var index = int.!(tableNumber - 1);
				var oldEntry = tables[index];
				match (oldEntry) {
					ReserveIndirect(mt) => {
						if (mt != mtable) {
							var sb = StringBuilder.new()
									      .put2("expected mtable for %q but have mtable for %q",
										    mtable.render, mt.render);
							context.fail(sb.extract());
						}
					}
					_ => context.fail1("unexpected table info %q", oldEntry.render);
				}
				tables[index] = tinfo;
			}
		}
	}
}
// adds to the gcTypeTable all non-class heap types
def addIrTypes<T>(irObject: T, prog: WasmGcProgram) {
	var errgen = prog.mach.prog.ERROR;
	match (irObject) {
		module: IrModule => {
			if (WasmComponent.printSection.TYPE) {
				errgen.addError(null, null, "Type Section", "Processing module");
			}
			// *Add* all the classes first, so their ctypes are in heapTypeMap, etc
			for (i < module.classes.length) prog.gcTypeTable.addClass(module.classes[i]);
			// Now process the classes (etc) more thoroughly
			for (i < module.classes.length) addIrTypes(module.classes[i], prog);
			for (i < module.methods.length) addIrTypes(module.methods[i], prog);
			for (i < module.init.length   ) addIrTypes(module.init   [i], prog);
			for (i < module.roots.length  ) addIrTypes(module.roots  [i], prog);
		}
		cls: IrClass => {
			// finish processing the class - could not process the fields with addClass
			if (WasmComponent.printSection.TYPE) {
				var ctype = cls.ctype;
				var name: string = if(ClassType.?(ctype),ClassType.!(ctype).classDecl.name(),ctype.typeCon.name);
				var line = StringBuilder.new().put1("Processing IR class: %s", name);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			prog.gcTypeTable.processClass(cls, prog.mach.tagType);
			// go through the rest
			for (m in cls.methods) addIrTypes(m, prog);
			for (f in cls.fields ) addIrTypes(f, prog);
		}
		method: IrMethod => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put2("Processing IR method: %q.%q",
								    method.receiver.render, method.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			prog.gcTypeTable.addSignature(prog.getSig(method.receiver, method.sig));
		}
		field: IrField => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put3("Processing IR field: %q.%q: %q",
								    field.receiver.render, field.render, field.fieldType.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			prog.gcTypeTable.addHeapType(field.fieldType);
		}
		selector: IrSelector => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put2("Processing IR selector: %q.%q",
								    selector.receiver.render, selector.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(selector.method, prog);
			addIrTypes(selector.mtable, prog);
		}
		mtable: IrMtable => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put1("Processing IR mtable: %q", mtable.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(mtable.root, prog);
			for (meth in mtable.table) addIrTypes(meth, prog);
			prog.gcTypeTable.addHeapType(mtable.record.rtype);
		}
		spec: IrSpec => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put1("Processing IR spec: %q", spec.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(spec.member, prog);
			for (typ in spec.typeArgs) prog.gcTypeTable.addHeapType(typ);
		}
		root: IrRoot => {
			if (WasmComponent.printSection.TYPE) {
				var name = if(root.name == null,"??",root.name);
				var line = StringBuilder.new().put1("Processing IR root: %s", name);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(root.spec, prog);
		}
	}
}

class WasmGcLowering extends MachLowering {

	def wasm: WasmGcProgram;
	def target: WasmGcTarget;

	new(wasm, target, mach: MachProgram, compiler: Compiler, config: MachLoweringConfig)
		super(mach, compiler, config) {	}

	def classIdRange(t: Type) -> (int, int) {
		var r = mach.prog.ir.getIrClass(t);
		if (r == null) return (0, 0);
		return (r.minClassId, r.maxClassId);
	}
	def genSimpleVal(val: Val, tn: TypeNorm) -> Val {
		if (val == null) return null;
		match (val) {
			x: ArrayRangeStart => return Int.box(x.start);
			x: PointerRangeStart => return x.start;
		}
		return mach.machVal(val);
	}
	def genClassCast(ft: Type, tt: Type, i_old: SsaApplyOp) -> SsaInstr {
		var fromIrClass = mach.prog.ir.getIrClass(ft);
		wasm.gcTypeTable.addClass(fromIrClass);
		var toIrClass = mach.prog.ir.getIrClass(ft);
		wasm.gcTypeTable.addClass(toIrClass);
		return normId(i_old);
	}
	def genTypeQuery(i_old: SsaApplyOp, query: TypeQuery) -> SsaInstr {
		var ft = i_old.op.typeArgs[0], tt = i_old.op.typeArgs[1];
		if (V3.isClass(ft) && V3.isClass(tt)) {
			var oobj = i_old.inputs[0], nobj = normRef1(oobj);
			var t = classIdRange(tt), low = t.0, high = t.1;
			if (low == high) {
				// no live classes can match, and null is not an instance of
				return context.graph.falseConst();
			}
// EBM use first return to demo why REF_TEST does not work
//			return normId(i_old);
			return genIfNull(i_old, Bool.TYPE, nobj, null, genClassIdQuery(i_old, low, high, _));
		}
		return context.graph.trueConst();
	}
	def genClassIdQuery(i_old: SsaApplyOp, low: int, high: int, nobj: SsaInstr) -> SsaInstr {
		var tagType = mach.tagType;
		var fromType = i_old.op.typeArgs[0];
		var field = IrField.new(fromType, tagType);
		field.machOffset = 0;  // flags a tag field
		var spec = IrSpec.new(fromType, null, field);
		var i_tid = apply(i_old.source, V3Op.newClassGetField(spec), [i_old.input0()]);
		return genRangeQuery(i_old, low, high, i_tid);
	}
	def genRangeQuery(i_old: SsaApplyOp, low: int, high: int, val: SsaInstr) -> SsaInstr {
		if (high == low + 1) { // XXX: better factoring of degenerate range checks
			return apply(i_old.source, V3Op.newEqual(Int.TYPE), [val, context.graph.intConst(low)]);
		} else {
			var cmp1 = curBlock.opIntGteq(val, context.graph.intConst(low));
			var cmp2 = curBlock.opIntLt(val, context.graph.intConst(high));
			return apply(i_old.source, V3Op.opBoolAnd, [cmp1, cmp2]);
		}
	}
	def genTypeSubsume(i_old: SsaApplyOp) {
		// Actually need the (static) type to change in Wasm code, so need a cast
		void(normId(i_old));
	}
	def genArrayAlloc(i_old: SsaApplyOp) -> SsaInstr {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.returnTypes[0]);
		return normId(i_old);
	}
	def genArrayInit(i_old: SsaApplyOp) -> SsaInstr {
		var arrayType = i_old.op.typeArgs[0];
		wasm.gcTypeTable.addHeapType(arrayType);
		return normId(i_old);
	}
	def genArrayTupleInit(i_old: SsaApplyOp, elems: int, length: int) -> SsaInstr {
		// should not happen since MixedArrays is turned off
		wasm.context.fail("genArrayTupleInit called but MixedArrays is false");
		return normId(i_old);	// satisfy compiler
	}
	def genArrayGetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return void(normId(i_old));
	}
	def genArraySetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return void(normId(i_old));
	}
	def genRangeStartPlusIndex(i_old: SsaApplyOp) -> SsaInstr {
		var rangeType = i_old.op.typeArgs[0];
		wasm.gcTypeTable.addHeapType(rangeType);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0];
		var rangeStart = inputs[1];
		var nindex = inputs[2]; // XXX: discarding upper words for normalized integers
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		var i_new: SsaInstr;


		var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			if (narr.facts.V_ZERO) {
				i_new = ptrAdd(rangeStart, nindex);
			} else if (narr.facts.V_NON_ZERO) {
				i_new = sum;
			} else {
				var t = addIfNull(narr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var aresult = sum;
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var mresult = ptrAdd(rangeStart, nindex);
				tblock.addGoto(merge.block);

				curBlock = merge;
				i_new = curBlock.addPhi(etype, [aresult, mresult]);
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					if (narr.facts.V_ZERO) {
						var prod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						i_new = ptrAdd(rangeStart, prod);
					} else if (narr.facts.V_NON_ZERO) {
						i_new = sum;
					} else {
						var t = addIfNull(narr);
						var tblock = t.0, fblock = t.1, merge = t.2;
						curBlock = fblock;
						// if (nobj != null) generate the nonnull (array) case
						var aresult = sum;
						fblock.addGoto(merge.block);

						// if (nobj == null) generate the null (memory) case
						curBlock = tblock;
						var mprod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var mresult = ptrAdd(rangeStart, mprod);
						tblock.addGoto(merge.block);

						curBlock = merge;
						i_new = curBlock.addPhi(etype, [aresult, mresult]);
					}
				}
				_ => {
					// no explicit null check needed
					i_new = sum;
				}
			}
		}
		map1(i_old, i_new);
		return i_new;
	}
	def genNormRangeGetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0], rangeStart = inputs[1], nindex = inputs[2], rangeType = i_old.op.typeArgs[0];
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		// op is usually needed
		var op = Operator.new(Opcode.ArrayGetElem, i_old.op.typeArgs, Function.siga(i_old.op.typeArgs, etype));
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
			if (narr.facts.V_ZERO) {
				var result = apply(null, V3Op.newPtrLoad(mach.data.ptrType, etype), [sum]);
				map1(i_old, result);
			} else if (narr.facts.V_NON_ZERO) {
				var result = apply(null, op, [narr, sum]);
				map1(i_old, result);
			} else {
				var t = addIfNull(narr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var aresult = apply(null, op, [narr, sum]);
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var mresult = apply(null, V3Op.newPtrLoad(mach.data.ptrType, etype), [sum]);
				tblock.addGoto(merge.block);

				curBlock = merge;
				map1(i_old, curBlock.addPhi(etype, [aresult, mresult]));
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					if (narr.facts.V_ZERO) {
						var prod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, prod]);
						var result = apply(i_old.source, V3Op.newPtrLoad(mach.data.ptrType, etype), [sum]);
						map1(i_old, result);
					} else if (narr.facts.V_NON_ZERO) {
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var result = apply(i_old.source, op, [narr, sum]);
						map1(i_old, result);
					} else {
						var t = addIfNull(narr);
						var tblock = t.0, fblock = t.1, merge = t.2;
						curBlock = fblock;
						// if (nobj != null) generate the nonnull (array) case
						var asum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var aresult = apply(i_old.source, op, [narr, asum]);
						fblock.addGoto(merge.block);

						// if (nobj == null) generate the null (memory) case
						curBlock = tblock;
						var mprod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var msum = apply(i_old.source, itype.opAdd(), [rangeStart, mprod]);
						var mresult = apply(i_old.source, V3Op.newPtrLoad(mach.data.ptrType, etype), [msum]);
						tblock.addGoto(merge.block);

						curBlock = merge;
						map1(i_old, curBlock.addPhi(etype, [aresult, mresult]));
					}
				}
				_ => {
					// no explicit null check needed
					var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
					var result = apply(null, op, [narr, sum]);
					map1(i_old, result);
				}
			}
		}
	}
	def genNormRangeSetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0], rangeStart = inputs[1], nindex = inputs[2], nval = inputs[3], rangeType = i_old.op.typeArgs[0];
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		// op is usually needed
		var arrParamTypes = [i_old.op.sig.paramTypes[0], i_old.op.sig.paramTypes[2], i_old.op.sig.paramTypes[3]];
		var op = Operator.new(Opcode.ArraySetElem, i_old.op.typeArgs, Signature.new(null, arrParamTypes, []));
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
			if (narr.facts.V_ZERO) {
				var result = apply(null, V3Op.newPtrStore(mach.data.ptrType, etype), [sum, nval]);
				map1(i_old, result);
			} else if (narr.facts.V_NON_ZERO) {
				var result = apply(null, op, [narr, sum, nval]);
				map1(i_old, result);
			} else {
				var t = addIfNull(narr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var aresult = apply(null, op, [narr, sum, nval]);
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var mresult = apply(null, V3Op.newPtrStore(mach.data.ptrType, etype), [sum, nval]);
				tblock.addGoto(merge.block);

				curBlock = merge;
				i_old.remove();
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					if (narr.facts.V_ZERO) {
						var prod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, prod]);
						var result = apply(i_old.source, V3Op.newPtrStore(mach.data.ptrType, etype), [sum, nval]);
						map1(i_old, result);
					} else if (narr.facts.V_NON_ZERO) {
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var result = apply(i_old.source, op, [narr, sum, nval]);
						map1(i_old, result);
					} else {
						var t = addIfNull(narr);
						var tblock = t.0, fblock = t.1, merge = t.2;
						curBlock = fblock;
						// if (nobj != null) generate the nonnull (array) case
						var asum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var aresult = apply(i_old.source, op, [narr, asum, nval]);
						fblock.addGoto(merge.block);

						// if (nobj == null) generate the null (memory) case
						curBlock = tblock;
						var mprod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var msum = apply(i_old.source, itype.opAdd(), [rangeStart, mprod]);
						var mresult = apply(i_old.source, V3Op.newPtrStore(mach.data.ptrType, etype), [msum, nval]);
						tblock.addGoto(merge.block);

						curBlock = merge;
						i_old.remove();
					}
				}
				_ => {
					// no explicit null check needed
					var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
					var result = apply(null, op, [narr, sum, nval]);
					map1(i_old, result);
				}
			}
		}
	}
	def genArrayGetLength(i_old: SsaApplyOp) -> SsaInstr {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return normId(i_old);
	}
	def genClassAlloc(i_old: SsaApplyOp, method: IrMethod) {
		// Leave the ClassAlloc for code gen, which will set the tag
		// If method is non-null, add call to the graph
		var classType = i_old.op.sig.returnTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
		// insert a copy of the current instr (so we can add *after*)
		var dests = Arrays.map(i_old.inputs, SsaDfEdge.getDest);
		var i_new = curBlock.addApply(i_old.source, i_old.op, dests);
		if (method != null) {
			var methodRef = V3Op.extractIrSpec(i_old.op, method);
			var funcRep = mach.funcRep(methodRef);
			var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
			var args = Arrays.prepend(func, Arrays.prepend(i_new, normRefs(i_old.inputs)));
			apply(i_old.source, V3Op.newCallClassMethod(methodRef), args);
		}
		map1(i_old, i_new);
	}
	def genVariantAlloc(i_old: SsaApplyOp) {
		// Leave the VariantAlloc for code gen, which adds the tag itself
		var classType = i_old.op.sig.returnTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
	}
	def genClassGetField(isVariant: bool, i_old: SsaApplyOp, field: IrField) {
		// Leave the ClassGetField for code gen
		var classType = i_old.op.sig.paramTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
		// Ben indicates that the multiple-types for a field should not happen on Wasm Gc;
		// it is for handing 64-bit numbers on 32-bit platforms.
	}
	def genClassSetField(i_old: SsaApplyOp, field: IrField, init: bool) {
		// Leave the ClassGetField for code gen
		var classType = i_old.op.sig.paramTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		return void(normId(i_old));
	}
	def genClassGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {
		genNullCheck(i_old);
		wasm.requestIndirectAdapter(method);
//		wasm.addIrMethodAddr(method, target.addrOfMethod(mach, method));
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		return context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
	}
	def genClassGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {
		// insure class is recorded
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and indirect adapters requested
		wasm.requestIndirectTable(selector.mtable);
//		wasm.getIndirectTableNumber(selector.mtable);

		// pass through to code gen
		return normId(i_old);
	}
	def genVariantGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {
		wasm.requestIndirectAdapter(method);
//		wasm.addIrMethodAddr(method, target.addrOfMethod(mach, method));
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		return context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
	}
	def genVariantGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {
		// insure class is recorded
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and indirect adapters requested
		wasm.requestIndirectTable(selector.mtable);
//		wasm.getIndirectTableNumber(selector.mtable);

		// pass through to code gen
		return normId(i_old);
	}
/*
	def genMtableLookup(i_old: SsaApplyOp, oobj: SsaDfEdge, nobj: SsaInstr, funcRep: Mach_FuncRep, methodRef: IrSpec) -> SsaInstr {
		// for WasmGc creates code to compute the dispatch offset into the method table
		// and obtain the function reference

		normId(i_old);

		var selector = IrSelector.!(methodRef.member);
		// insure that method table is recorded
		wasm.getMtableNumber(selector.mtable);
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);

		// insure class is recorded
		wasm.gcTypeTable.addClass(irClass);

		// create IrField for tag and add ClassGetField operation
		var tagType = mach.tagType;
		var field = IrField.new(classType, tagType);
		field.machOffset = 0;  // flags a tag field
		var spec = IrSpec.new(classType, null, field);
		var i_tag = apply(i_old.source, V3Op.newClassGetField(spec), [i_old.input0()]);

		// add IntSub of minClassId to produce offset into method table
		var classId = irClass.minClassId;
		var idVal = context.graph.valConst(tagType, Int.box(classId));
		var sig = Function.siga([tagType, tagType], tagType);
		var i_offset = apply(i_old.source, Operator.new(Opcode.IntSub, [tagType], sig), [i_tag, idVal]);

		return i_offset;
	}
*/
	def genComponentGetField(i_old: SsaApplyOp, field: IrField) {
		// Leave the ComponentGetField for code gen
		return void(normId(i_old));
/*
		var fieldRef = V3Op.extractIrSpec(i_old.op, field);
		var fieldType = mach.machType(fieldRef.getFieldType());
		var ptr = componentFieldPtr(fieldRef);
		var loads = genNormTypedLoads(i_old.source, Fact.O_NO_NULL_CHECK, fieldType, ptr, 0);
		mapN(i_old, loads);
*/
	}
	def genComponentSetField(i_old: SsaApplyOp, field: IrField) {
		// Leave the ComponentSetField for code gen
		return void(normId(i_old));
/*
		var fieldRef = V3Op.extractIrSpec(i_old.op, field);
		var inputs = normRefs(i_old.inputs);
		var machType = mach.machType(fieldRef.getFieldType());
		var ptr = componentFieldPtr(fieldRef);
		// generate remaining stores for normalized fields.
		genNormTypedStores(i_old.source, Fact.O_NO_NULL_CHECK, false, machType, ptr, 0, inputs, 1);
		i_old.kill();
		i_old.remove();
*/
	}
	def genBoundsCheck0(i_old: SsaApplyOp, nullity: Fact.set, narr: SsaInstr) -> (SsaInstr, Fact.set) {
		return (normId(i_old), nullity);
/*
		var oarr = i_old.inputs[0];
		// load length
		// XXX: CSE the array length if possible
		var len = refLoad(nullity, Int.TYPE, i_old, oarr, narr, mach.getArrayLengthOffset(i_old.op.typeArgs[0]));
		var index = normRef1(i_old.inputs[1]);
		var throwOp = V3Op.newConditionalThrow(V3Exception.BoundsCheck);
		// throw BoundsCheckException if ugteq(index, length)
		var op = Int.getType(false, 32).opLtEq();
		apply(i_old.source, throwOp, [apply(i_old.source, op, [len, index])]);
		return (index, nullity | Fact.O_NO_NULL_CHECK);
*/
	}
	def genCallMethod(i_old: SsaApplyOp, method: IrMethod) {
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
		var args = Arrays.prepend(func, normRefs(i_old.inputs));

		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);

//		var tblnum = Int.box(0);
//		var tbl = context.graph.valConst(Int.getType(false, 31), tblnum);
//		args = Arrays.prepend(tbl, args);

//		call(i_old, funcRep, args);
	}
	def genCallClassMethod(i_old: SsaApplyOp, method: IrMethod) {
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
		var args = Arrays.prepend(func, normRefs(i_old.inputs));

		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);

//		var tblnum = Int.box(0);
//		var tbl = context.graph.valConst(Int.getType(false, 31), tblnum);
//		args = Arrays.prepend(tbl, args);

//		call(i_old, funcRep, args);
	}
	def genCallClassSelector(i_old: SsaApplyOp, selector: IrSelector) {
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		// insure class type is entered
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and dispatch adapters requested
		wasm.requestDispatchTable(selector.mtable);
//		wasm.getDispatchTableNumber(selector.mtable);

		var args = normRefs(i_old.inputs);
		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallVariantSelector(i_old: SsaApplyOp, selector: IrSelector) {
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		// insure class type is entered
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and dispatch adapters requested
		wasm.requestDispatchTable(selector.mtable);
//		wasm.getDispatchTableNumber(selector.mtable);

		var args = normRefs(i_old.inputs);
		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallFunction(i_old: SsaApplyOp) {
//		wasm.context.fail("genCallFunction called");
		var funcRep = mach.getFuncRep(i_old.op.typeArgs[0]);
		var ptype = funcRep.machType;
		var args = normRefs(i_old.inputs);
		// essentially the same instruction; helps code below work
		var i_new = apply(i_old.source, i_old.op, args);
		i_new.facts = i_new.facts | i_old.facts;
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genVariantGetTag(i_old: SsaApplyOp, nobj: SsaInstr) -> SsaInstr {
		return normId(i_old);
/*
		var val = ptrLoad(mach.tagType, nobj, 0);
		var root = V3.getRootType(i_old.op.typeArgs[0]);
		var min = mach.classIdRange(root).0;
		if (min != 0) {
			val = apply(i_old.source, mach.tagType.opSub(), [val, context.graph.intConst(min)]);
		}
		var shift = mach.code.addressSizeLog2;
		if (shift > 0) {
			val = apply(i_old.source, mach.tagType.opShr(), [val, context.graph.intConst(shift)]);
		}
		var conv = V3Op.newIntViewI(mach.tagType, i_old.op.sig.returnType());
		return apply(i_old.source, conv, [val]);
*/
	}
	def genNullCheck0(source: Source, nobj: SsaInstr) {
		if (SsaConst.?(nobj)) {
			var oval = SsaConst.!(nobj).val;
			if (oval == null) addThrow(source, V3Exception.NullCheck);
			return; // constant is non-null
		}
		explicitNullCheck(source, nobj.getType(), nobj);
	}
	def call(i_old: SsaApplyOp, funcRep: Mach_FuncRep, args: Array<SsaInstr>) {
		if (curBlock.end) return;
		var i_new = apply(i_old.source, V3Op.newCallAddress(funcRep), args);
		i_new.facts = i_new.facts | i_old.facts;
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
}
