// Copyright 2022 Ben L. Titzer and 2024-2025 Eliot Moss. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// This file adds functionality needed by the WasmGc back end but not by the
// Wasm back end.

enum WasmDefTypeCode(code: byte, val: i7) {
	Function	(0x60, -32),
	Struct		(0x5F, -33),
	Array		(0x5E, -34),
	Continuation	(0x5D, -35),
	SUB		(0x50, -48),
	SUB_FINAL	(0x4F, -49),
	REC		(0x4E, -50),
}

// Information for graph algorithm that discovers recursion groups, etc.
class WasmGcTypeInfo(wtype: WasmHeapType) {
	def var predecessors: List<WasmGcTypeInfo>;
	def var successors: List<WasmGcTypeInfo>;
	var visited: bool;
	def addEdgeTo(target: WasmGcTypeInfo) {
		if (target == null) return;
		successors = List.new(target, successors);
		target.predecessors = List.new(this, target.predecessors);
	}
	def addEdgeToHeapType(target: WasmHeapType) {
		if (target == null) return;
		addEdgeTo(target.getTypeInfo());
	}
	def addEdgeToType(target: Type, table: WasmGcTypeTable) {
		var wht = table.heapTypeMap[target];
		addEdgeToHeapType(wht);
	}
}

// Canonicalizes and encodes Virgil types and signatures into WASM GC types and function sigs
class WasmGcTypeTable(wasmType: Type -> WasmValueType) {
	// Signatures are treated differently.  Because they don't arrive as Virgil types,
	// already canonicalized, their Wasm form needs its own canonicalization.  Also,
	// they are not of themselves recursive.

	// Map for canonicalizing and mapping Signatures
	def signatureMap = HashMap<Signature, WasmFuncType>.new(Signature.hash, Signature.equals);

	// Map indicating which Wasm type is used to represent each (canonicalized) Virgil
	// heap type, except for class types
	def heapTypeMap = TypeUtil.newTypeMap<WasmHeapType>();

	// Map indicating the Wasm type for each IrClass; these do not appear in heapTypeMap
	def classMap = HashMap<IrClass, WasmStructType>.new(IrItem.uid, IrClass.==);

	// These hold the various WasmHeapTypes and associated data so we can go through them later
	def structTypes   = Vector<(WasmStructType, IrClass  )>.new();
	def arrayTypes    = Vector<(WasmArrayType , Type     )>.new();
	def functionTypes = Vector<(WasmFuncType  , Signature)>.new();

	def eltTypeMap = HashMap<WasmStorageType, WasmArrayType>.new(
		WasmStorageType.hash, WasmStorageType.equals
		);	// WASM array element type -> WasmArrayType

	// The (recursion) groups of types for eventual output in the type section of a Wasm module
	def var typeGroups: Vector<Vector<WasmGcTypeInfo>>;

	// Note: since index 0 means "unassigned", the actual Wasm type index
	// for a type is one smaller than the WasmType index field.  Thus
	// maxIndex is also the number of type indices assigned so far.
	def var maxIndex: u32 = 0;

	// EBM --- plan for processing types
	// 1) Walk over the IR finding Virgil Types
	//   a) Add each heap Type to a hash table (heapTypeMap)
	//   b) If a Type is new, create a WasmHeapType for it, leaving its outgoing references "blank"
	// 2) Go through the heapTypeMap and create WasmGcTypeInfo edges between the types
	// 3) Walk the resulting graph using findTypeGroups to discover recursive groups, etc.
	// 4) Apply finite state machine style minimization to each recursive group
	// 5) Assign Wasm type numbers to groups in order, checking for Wasm type equivalence,
	//    using a finite state machine equivalence algorithm.  This canonicalizes the
	//    Wasm heap types so that equivalent type get the same number (the WasmHeapType
	//    objects may still be distinct).  This builts a "compacted" list of WasmHeapTypes
	//    that can be used for the (initial part of the) Wasm module's type table
	//    This step also fills in the "blank" parts of the WasmHeapTypes since any target
	//    heap types now have final type numbers.
	//
	// It is possible that code generation will find more types later, though they must
	// not be recursive.  These should be processed in similar stages to the above:
	// a) Add to heapTypeMap if necessary, creating a new WasmHeapType
	// b) Search the WasmHeapType canonicalization table to determine and existing type
	//    number, or assign a new one.
	// c) Fill in the "blank" parts of the WasmHeapType (if it was new).


	// Adds a heap Type to heapTypeMap, if not already present.  Returns the WasmHeapType,
	// giving null if the type is for a scalar.
	def addHeapType(typ: Type) -> WasmHeapType {
		var wht = heapTypeMap[typ];
		if (wht == null) {
			match (typ.typeCon.kind) {
				ARRAY => wht = addArrayType(typ);
				FUNCREF, CLOSURE => wht = addSignature(FuncType.!(typ).sig());
				// CLASS, VARIANT => ...  shouldn't happen
				_ => return null;
			}
			heapTypeMap[typ] = wht;
		}
		return wht;
	}

	// adds an IrClass to classMap, its class type to heapTypemap,
	// and its struct type to structTypes
	def addClass(cls: IrClass) -> WasmHeapType {
		// ignore if already present
		var wht = classMap[cls];
		if (wht == null) {
			var st = WasmStructType.new().initTypeInfo();
			classMap[cls] = st;
			heapTypeMap[cls.ctype] = wht = st;
		}
		return wht;
	}
	def processClass(cls: IrClass) {
		var st = classMap[cls];
		if (cls.parent != null) {
			st.addEdgeTo(st.parent = WasmStructType.!(addHeapType(cls.parent.ctype)));
		}
		var flds = cls.fields;
		var wflds = st.fields = Array<WasmStorageType>.new(flds.length);
		for (i < flds.length) {
			// tag is immutable, rest are mutable
			var wstype = wflds[i] = getStorageTypeFor(flds[i].fieldType, i > 0);
			st.addEdgeTo(wstype.heapType());
		}
	}

	// add a Signature to signatureMap and its function type to heapTypeMap
	def addSignature(sig: Signature) -> WasmFuncType {
		var wft = signatureMap[sig];
		if (wft == null) {
			var ft = sig.funcType();
			var entry = heapTypeMap[ft];
			if (entry == null) {
				var ptypes = sig.paramTypes;
				var rtypes = sig.returnTypes;
				var params = Array<WasmValueType>.new(ptypes.length);
				var results = Array<WasmValueType>.new(rtypes.length);
				wft = WasmFuncType.new(params, results).initTypeInfo();
				heapTypeMap[ft] = wft;
				for (i < params.length) {
					var wvtype = params[i] = getValueTypeFor(ptypes[i]);
					wft.addEdgeTo(wvtype.heapType());
				}
				for (i < results.length) {
					var wvtype = results[i] = getValueTypeFor(rtypes[i]);
					wft.addEdgeTo(wvtype.heapType());
				}
			} else {
				wft = WasmFuncType.!(entry);
			}
			signatureMap[sig] = wft;
		}
		return wft;
	}

	// Add an array type given its element type
	def addArrayType(atype: Type) -> WasmArrayType {
		var wat = WasmArrayType.new().initTypeInfo();
		heapTypeMap[atype] = wat;
		var etype = V3Array.elementType(atype);
		var estype = wat.elem = getStorageTypeFor(etype, true);
		wat.addEdgeTo(estype.heapType());
		return wat;
	}

	// Support for dfs0 helper

	private def dfs0_visit(stack: ListStack<WasmGcTypeInfo>, node: WasmGcTypeInfo) {
		if (node.visited) return;
		node.visited = true;
		for (e = node.successors; e != null; e = e.tail) {
			dfs0_visit(stack, e.head);
		}
		stack.push(node);
	}

	// Helper for first depth-first search of the type graph
	private def dfs0(stack: ListStack<WasmGcTypeInfo>, t: Type, wt: WasmHeapType) {
		// Note: we don't use getTypeInfo here so that we catch any
		// case where the info is absent
		dfs0_visit(stack, wt.typeInfo);
	}

	// Builds a single strongly connected component by doing a DFS from a
	// given node over predecessors
	private def dfs1(comp: Vector<WasmGcTypeInfo>, node: WasmGcTypeInfo) {
		if (node.visited) return;
		node.visited = true;
		comp.put(node);
		for (e = node.predecessors; e != null; e = e.tail) {
			dfs1(comp, e.head);
		}
	}

	// After a pass over the classes (etc.), we should have enough types
	// entered, with their WasmType's, to form recursion groups and assign
	// type indices.  We do this by running a strongly connected
	// components (SCC) algorithm over the graph of types.  Once we have
	// the SCCs, we order them by repeatedly finding SCCs all of whose
	// predecessors have already been found.
	private def findTypeGroups() {
		// This is an implementation of the Kosaraju-Sharir algorithm.

		// Step 1: Do a depth-first search and push nodes on a stack
		// in the order in which we *finish* with them.
		var stack = ListStack<WasmGcTypeInfo>.new();
		heapTypeMap.apply(dfs0(stack, _, _));
		// reset visited for second DFS
		for (node = stack.top; node != null; node = node.tail) {
			node.head.visited = false;
		}

		// Step 2: Do a depth-first search *over successors* to find
		// components.  Importantly, this proceeds in reverse of the
		// order in which Step 1 pushed nodes.
		var components = Vector<Vector<WasmGcTypeInfo>>.new();
		while (!stack.empty()) {
			var node = stack.pop();
			if (node.visited) continue;
			var comp = Vector<WasmGcTypeInfo>.new();
			dfs1(comp, node);
			components.put(comp);
		}

		// At this point the components vector has the type groups in
		// forward order.  This is because, in stack, if there is a
		// forward path from node u to node v, then either they are in
		// the same component (in which case the order of u and v is
		// arbitrary) or u was pushed to the stack *after* v.  This
		// means that if u and v lie in different components and there
		// is a path from u to v, u's component will occur earlier in
		// components than v's will.  Each component is a recursion
		// group for Wasm type purposes, though singletons will not be
		// output as recursion groups.

		// We reverse the lsit so that we get leaves first.
		typeGroups = components.reverse();
	}

	// This fills in fields (etc.) of types entered so far, then finds the
	// recursion groups of types and assign type indices.  Any types
	// encountered later may refer to these types, but may not be recursive.
	// Such types should be added using insureTypeAdded.
	def assignTypeIndices() {
		findTypeGroups();
		var idx: i32 = 0;
		for (i < typeGroups.length) {
			var group = typeGroups[i];
			for (j < group.length) {
				group[j].wtype.index = ++maxIndex;
			}
		}
	}

	// This returns Wasm value types, not heap types
	// Non-recursive ("top-level") function
	def addValueType(t: Type) -> WasmValueType {
		match (t) {
			null => return WasmValueType.Void;
			x: IntType => return if(x.width > 32, WasmValueType.I64, WasmValueType.I32);
			x: FloatType => return if(x.is64, WasmValueType.F64, WasmValueType.F32);
			x: AnyRefType => return WasmValueType.AnyRef;
			x: NullType => return WasmValueType.NoneRef;
			_ => match (t.typeCon.kind) {
				ENUM => return wasmType(V3.getVariantTagType(t));
				ENUM_SET => return wasmType(V3.getEnumSetType(t));
				ARRAY, CLASS, VARIANT, FUNCREF =>
			 	      return addWasmRefType(t); // TODO
				_ => return WasmValueType.Void;
			}
		}
	}

	// Wraps a heap type with a layer of Wasm ref
	private def addWasmRefType(t: Type) -> WasmValueType {
		var wht = addHeapType(t);
		if (wht == null) {
			// System.err.puts(t.render(StringBuilder.new()).put1("addWasmRefType got null for %q\n", t.render).extract());
			var i = 1/0;
		}
		return WasmValueType.RefNull(wht);
	}

	// This returns Wasm value types, not heap types
	// Non-recursive ("top-level") function
	def getValueTypeFor(t: Type) -> WasmValueType {
		match (t) {
			null => return WasmValueType.Void;
			x: IntType => return if(x.width > 32, WasmValueType.I64, WasmValueType.I32);
			x: FloatType => return if(x.is64, WasmValueType.F64, WasmValueType.F32);
			x: AnyRefType => return WasmValueType.AnyRef;
			x: NullType => return WasmValueType.NoneRef;
			_ => match (t.typeCon.kind) {
				ENUM => return wasmType(V3.getVariantTagType(t));
				ENUM_SET => return wasmType(V3.getEnumSetType(t));
				ARRAY, CLASS, VARIANT, FUNCREF =>
			 	      return addWasmRefType(t);
				_ => return WasmValueType.Void;
			}
		}
	}
	def getStorageTypeFor(t: Type, mutable: bool) -> WasmStorageType {
		return WasmStorageType(packingForType(t), getValueTypeFor(t), mutable);
	}
	def packingForType(t: Type) -> WasmPacking {
		match (t) {
			x: IntType => {
				if (x.width <= 8) return WasmPacking.PACKED_8;
				else if (x.width <= 16) return WasmPacking.PACKED_16;
				else return WasmPacking.NONE;
			}
			_ => return WasmPacking.NONE;
		}
	}

	// This is used after the initial building of the types table from
	// IrModule information, to insure that types encountered in code
	// (etc.?) are added to the type table.  They should form (at most) an
	// acyclic graph of new nodes untilmately referring only to scalar
	// type or types previously entered.
	def insureTypeAdded(typ: Type) {
		if (heapTypeMap[typ] != null) {
			// EBM maybe check that the WasmHeapType is complete
			return;
		}
		match (typ.typeCon.kind) {
			ARRAY => {
				// make sure the element type is recorded first (if a heap type)
				var etype = V3Array.elementType(typ);
				insureTypeAdded(etype);
				// make sure the array type is constructed and recorded
				var wat = addArrayType(typ);
				// assign type index if necessary
				if (wat.index == 0) {
					typeGroups.put(Vectors.of1<WasmGcTypeInfo>(wat.getTypeInfo()));
					wat.index = ++maxIndex;
					wat.complete = true;
				}
				return;
			}
			CLASS, VARIANT => return;	// should not happen
			FUNCREF, CLOSURE => {
				if (FuncType.?(typ)) {
					var sig = FuncType.!(typ).sig();
					// check if already canonicalized
					if (signatureMap[sig] != null) return;
					addSignature(sig);
					var wht = signatureMap[sig];
					// assign type index if necessary
					if (wht.index == 0) {
						var wft = WasmFuncType.!(wht);
						// make sure that all mentioned types are recorded first
						for (i < sig.paramTypes.length) {
							var t = sig.paramTypes[i];
							insureTypeAdded(t);
							wft.params[i] = getValueTypeFor(t);
						}
						for (i < sig.returnTypes.length) {
							var t = sig.returnTypes[i];
							insureTypeAdded(t);
							wft.results[i] = getValueTypeFor(t);
						}
						// add the WsmFuncType to the type groups
						typeGroups.put(Vectors.of1<WasmGcTypeInfo>(wft.getTypeInfo()));
						wft.index = ++maxIndex;
						wft.complete = true;
					}
				}
				return;
			}
			_ => return;	// ignore if not actually a heap type
		}
	}

	def emit(out: DataWriter) {
		// System.err.puts("outputting ").puti(typeGroups.length).puts(" typegroups\n");
		var cnt = 0;
		for (i < typeGroups.length) {
			var group = typeGroups[i];
			if (group.length > 1) {
				out.putb(WasmDefTypeCode.REC.code);
				out.put_uleb32(u32.!(group.length));
			}
			for (j < group.length) {
				// System.err.puts("type ").puti(cnt++).puts(" [#").puti(cnt).puts("] (").puti(i).puts("): ");
				match (group[j].wtype) {
					ft: WasmFuncType => {
						// System.err.puts("function(");
						out.putb(WasmDefTypeCode.Function.code);
						if (ft.params.length == 1 && WasmValueType.Void.?(ft.params[0])) {
							// System.err.puts("<empty>");
							out.put_uleb32(0);
						} else {
							out.put_uleb32(u32.!(ft.params.length));
							for (k < ft.params.length) {
								// System.err.puts(if(k > 0, ", ", "")).puts(StringBuilder.new().put1("%q", ft.params[k].render).extract());
								ft.params[k].put(out);
							}
						}
						if (ft.results.length == 1 && WasmValueType.Void.?(ft.results[0])) {
							// System.err.puts(")").ln();
							out.put_uleb32(0);
						} else {
							// System.err.puts(")").puts(if(ft.results.length > 0, " -> ", "")).puts(if(ft.results.length > 1, "(", ""));
							out.put_uleb32(u32.!(ft.results.length));
							for (k < ft.results.length) {
								// System.err.puts(if(k > 0, ", ", "")).puts(StringBuilder.new().put1("%q", ft.results[k].render).extract());
								ft.results[k].put(out);
							}
							// System.err.puts(if(ft.results.length > 1, ")", "")).ln();
						}
					}
					st: WasmStructType => {
						// System.err.puts("struct(");
						if (st.parent != null) {
							// System.err.puts("super=").puti(st.parent.index).puts(if(st.fields.length > 0, ", ", ""));
							out.putb(WasmDefTypeCode.SUB.code);
							out.put_uleb32(1);
							out.put_uleb32(st.parent.index);
						}
						out.putb(WasmDefTypeCode.Struct.code);
						out.put_uleb32(u32.!(st.fields.length));
						for (k < st.fields.length) {
							// System.err.puts(StringBuilder.new().put1("%q", st.fields[k].render).extract()).puts(if(k + 1 < st.fields.length, ", ", ""));
							st.fields[k].put(out);
						}
						// System.err.puts(")\n");
					}
					at: WasmArrayType => {
						out.putb(WasmDefTypeCode.Array.code);
						// System.err.puts(StringBuilder.new().put1("(array %q)\n", at.elem.render).extract());
						at.elem.put(out);
					}
					_ => { /* error */ }
				}
			}
		}
	}
}
