<<<<<<< HEAD
// Copyright 2022 Ben L. Titzer and 2024-2025 Eliot Moss. All rights reserved.
=======
// Copyright 2022 Ben L. Titzer. All rights reserved.
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
// See LICENSE for details of Apache 2.0 license.

// This file adds functionality needed by the WasmGc back end but not by the
// Wasm back end.

<<<<<<< HEAD
enum WasmDefTypeCode(code: byte, val: i7) {
	Function	(0x60, -32),
	Struct		(0x5F, -33),
	Array		(0x5E, -34),
	Continuation	(0x5D, -35),
	SUB		(0x50, -48),
	SUB_FINAL	(0x4F, -49),
	REC		(0x4E, -50),
=======
enum WasmDefTypeCode(code: i16, val: i32) {
	Function	(-0x20, -32),
	Struct		(-0x21, -33),
	Array		(-0x22, -34),
	Continuation	(-0x23, -35),
	SUB		(-0x30, -48),
	SUB_FINAL	(-0x31, -49),
	REC		(-0x32, -50),
}

// Edge classes for WasmGcTypeInfo
class InEdge extends Edge<WasmGcTypeInfo> {
	def getListHead(wti: WasmGcTypeInfo) -> InEdge { return wti.predecessors; }
	def setListHead(wti: WasmGcTypeInfo, e: Edge<WasmGcTypeInfo>) { wti.predecessors = InEdge.!(e); }
	new(src: WasmGcTypeInfo, dst: WasmGcTypeInfo) super(src, dst) { }
}
class OutEdge extends Edge<WasmGcTypeInfo> {
	def getListHead(wti: WasmGcTypeInfo) -> OutEdge { return wti.successors; }
	def setListHead(wti: WasmGcTypeInfo, e: Edge<WasmGcTypeInfo>) { wti.successors = OutEdge.!(e); }
	new(src: WasmGcTypeInfo, dst: WasmGcTypeInfo) super(src, dst) { }
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
}

// Information for graph algorithm that discovers recursion groups, etc.
class WasmGcTypeInfo(wtype: WasmHeapType) {
<<<<<<< HEAD
	def var predecessors: List<WasmGcTypeInfo>;
	def var successors: List<WasmGcTypeInfo>;
	var visited: bool;
	def addEdgeTo(target: WasmGcTypeInfo) {
		if (target == null) return;
		successors = List.new(target, successors);
		target.predecessors = List.new(this, target.predecessors);
	}
	def addEdgeToHeapType(target: WasmHeapType) {
		if (target == null) return;
		addEdgeTo(target.getTypeInfo());
	}
	def addEdgeToType(target: Type, table: WasmGcTypeTable) {
		var wht = table.heapTypeMap[target];
		addEdgeToHeapType(wht);
	}
=======
	private var predecessors: InEdge;
	private var successors: OutEdge;
	var visited: bool;
	def addInEdge(predecessor: WasmGcTypeInfo) { InEdge.new(this, predecessor); }
	def addOutEdge(successor: WasmGcTypeInfo) { OutEdge.new(this, successor); }
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
}

// Canonicalizes and encodes Virgil types and signatures into WASM GC types and function sigs
class WasmGcTypeTable(wasmType: Type -> WasmValueType) {
	// Signatures are treated differently.  Because they don't arrive as Virgil types,
	// already canonicalized, their Wasm form needs its own canonicalization.  Also,
	// they are not of themselves recursive.

	// Map for canonicalizing and mapping Signatures
<<<<<<< HEAD
	def signatureMap = HashMap<Signature, WasmFuncType>.new(Signature.hash, Signature.equals);

	// Map indicating which Wasm type is used to represent each (canonicalized) Virgil
	// heap type, except for class types
	def heapTypeMap = TypeUtil.newTypeMap<WasmHeapType>();

	// Map indicating the Wasm type for each IrClass; these do not appear in heapTypeMap
	def classMap = HashMap<IrClass, WasmStructType>.new(IrItem.uid, IrClass.==);

	// These hold the various WasmHeapTypes and associated data so we can go through them later
	def structTypes   = Vector<(WasmStructType, IrClass  )>.new();
	def arrayTypes    = Vector<(WasmArrayType , Type     )>.new();
	def functionTypes = Vector<(WasmFuncType  , Signature)>.new();

	def eltTypeMap = HashMap<WasmStorageType, WasmArrayType>.new(
		WasmStorageType.hash, WasmStorageType.equals
		);	// WASM array element type -> WasmArrayType
=======
	def signatureMap = HashMap<Signature, WasmHeapType>.new(Signature.hash, Signature.equals);

	// Map indicating which Wasm type is used to represent each (canonicalized) Virgil type
	def heapTypeMap = TypeUtil.newTypeMap<WasmHeapType>();

	// Map indicating the Wasm type for each (live) IrClass; we do not assume that all of
	// these appear in heapTypeMap
	def classMap = HashMap<IrClass, WasmHeapType>.new(IrItem.uid, IrClass.==);
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)

	// The (recursion) groups of types for eventual output in the type section of a Wasm module
	def var typeGroups: Vector<Vector<WasmGcTypeInfo>>;

	// Note: since index 0 means "unassigned", the actual Wasm type index
	// for a type is one smaller than the WasmType index field.  Thus
	// maxIndex is also the number of type indices assigned so far.
	def var maxIndex: u32 = 0;

<<<<<<< HEAD
	// EBM --- plan for processing types
	// 1) Walk over the IR finding Virgil Types
	//   a) Add each heap Type to a hash table (heapTypeMap)
	//   b) If a Type is new, create a WasmHeapType for it, leaving its outgoing references "blank"
	// 2) Go through the heapTypeMap and create WasmGcTypeInfo edges between the types
	// 3) Walk the resulting graph using findTypeGroups to discover recursive groups, etc.
	// 4) Apply finite state machine style minimization to each recursive group
	// 5) Assign Wasm type numbers to groups in order, checking for Wasm type equivalence,
	//    using a finite state machine equivalence algorithm.  This canonicalizes the
	//    Wasm heap types so that equivalent type get the same number (the WasmHeapType
	//    objects may still be distinct).  This builts a "compacted" list of WasmHeapTypes
	//    that can be used for the (initial part of the) Wasm module's type table
	//    This step also fills in the "blank" parts of the WasmHeapTypes since any target
	//    heap types now have final type numbers.
	//
	// It is possible that code generation will find more types later, though they must
	// not be recursive.  These should be processed in similar stages to the above:
	// a) Add to heapTypeMap if necessary, creating a new WasmHeapType
	// b) Search the WasmHeapType canonicalization table to determine and existing type
	//    number, or assign a new one.
	// c) Fill in the "blank" parts of the WasmHeapType (if it was new).


	// Adds a heap Type to heapTypeMap, if not already present.  Returns the WasmHeapType,
	// giving null if the type is for a scalar.
	def addHeapType(typ: Type) -> WasmHeapType {
		var wht = heapTypeMap[typ];
		if (wht == null) {
			match (typ.typeCon.kind) {
				ARRAY => wht = addArrayType(typ);
				FUNCREF, CLOSURE => wht = addSignature(FuncType.!(typ).sig());
				// CLASS, VARIANT => ...  shouldn't happen
				_ => return null;
			}
			heapTypeMap[typ] = wht;
		}
		return wht;
	}

	// adds an IrClass to classMap, its class type to heapTypemap,
	// and its struct type to structTypes
	def addClass(cls: IrClass) -> WasmHeapType {
		// ignore if already present
		var wht = classMap[cls];
		if (wht == null) {
			var st = WasmStructType.new().initTypeInfo();
			classMap[cls] = st;
			heapTypeMap[cls.ctype] = wht = st;
		}
		return wht;
	}
	def processClass(cls: IrClass) {
		var st = classMap[cls];
		if (cls.parent != null) {
			st.addEdgeTo(st.parent = WasmStructType.!(addHeapType(cls.parent.ctype)));
		}
		var flds = cls.fields;
		var wflds = st.fields = Array<WasmStorageType>.new(flds.length);
		for (i < flds.length) {
			// tag is immutable, rest are mutable
			var wstype = wflds[i] = getStorageTypeFor(flds[i].fieldType, i > 0);
			st.addEdgeTo(wstype.heapType());
		}
	}

	// add a Signature to signatureMap and its function type to heapTypeMap
	def addSignature(sig: Signature) -> WasmFuncType {
=======
	// Adds a heap Type to heapTypeMap.
	// If wasmType is null, then for ARRAY and FUNCREF/CLOSURE devises a WasmHeapType;
	// for other cases of null wasmType it does nothing.
	def addHeapType(typ: Type, wasmType: WasmHeapType) {
		if (heapTypeMap.has(typ)) return;
		if (wasmType == null) {
			match (typ.typeCon.kind) {
				ARRAY => {
					// we'll come back and fix the element type later
					var wat = WasmArrayType.new((WasmPacking.NONE, WasmValueType.Void));
					heapTypeMap[typ] = wat;
					// add element type (ignored if scalar, etc.)
					addHeapType(typ.nested.head, null);
					return;
				}
				CLASS, VARIANT => return;	// should not happen: need to add via IrClass
				FUNCREF, CLOSURE => {
					if (FuncType.?(typ)) addSignature(FuncType.!(typ).sig());
					return;
				}
				_ => return;	// ignore if not actually a heap type
			}
		}
		heapTypeMap[typ] = wasmType;
	}

	// adds an IrClass to classMap and its class type to heapTypemap
	def addClass(cls: IrClass) {
		// we assume parent is added first
		var parent: WasmHeapType = if(cls.parent == null, null, classMap[cls.parent]);
		var st = WasmStructType.new(WasmStructType.!(parent), null);
		addHeapType(cls.ctype, st);
	}

	// add a Signature to signatureMap and its function type to heapTypeMap
	def addSignature(sig: Signature) -> WasmHeapType {
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
		var wft = signatureMap[sig];
		if (wft == null) {
			var ft = sig.funcType();
			var entry = heapTypeMap[ft];
			if (entry == null) {
<<<<<<< HEAD
				var ptypes = sig.paramTypes;
				var rtypes = sig.returnTypes;
				var params = Array<WasmValueType>.new(ptypes.length);
				var results = Array<WasmValueType>.new(rtypes.length);
				wft = WasmFuncType.new(params, results).initTypeInfo();
				heapTypeMap[ft] = wft;
				for (i < params.length) {
					var wvtype = params[i] = getValueTypeFor(ptypes[i]);
					wft.addEdgeTo(wvtype.heapType());
				}
				for (i < results.length) {
					var wvtype = results[i] = getValueTypeFor(rtypes[i]);
					wft.addEdgeTo(wvtype.heapType());
				}
			} else {
				wft = WasmFuncType.!(entry);
=======
				var params = Array<WasmValueType>.new(sig.paramTypes.length);
				var results = Array<WasmValueType>.new(sig.returnTypes.length);
				wft = WasmFuncType.new(params, results);
				heapTypeMap[ft] = wft;
			} else {
				wft = WasmFuncType.!(heapTypeMap[ft]);
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
			}
			signatureMap[sig] = wft;
		}
		return wft;
	}

<<<<<<< HEAD
	// Add an array type given its element type
	def addArrayType(atype: Type) -> WasmArrayType {
		var wat = WasmArrayType.new().initTypeInfo();
		heapTypeMap[atype] = wat;
		var etype = V3Array.elementType(atype);
		var estype = wat.elem = getStorageTypeFor(etype, true);
		wat.addEdgeTo(estype.heapType());
		return wat;
	}

	// Support for dfs0 helper

	private def dfs0_visit(stack: ListStack<WasmGcTypeInfo>, node: WasmGcTypeInfo) {
		if (node.visited) return;
		node.visited = true;
		for (e = node.successors; e != null; e = e.tail) {
			dfs0_visit(stack, e.head);
		}
		stack.push(node);
	}

	// Helper for first depth-first search of the type graph
	private def dfs0(stack: ListStack<WasmGcTypeInfo>, t: Type, wt: WasmHeapType) {
=======
	// Obtain WasmGcTypeInfo, creating a new object if necessary
	private def getTypeInfo(wt: WasmHeapType) -> WasmGcTypeInfo {
		var info = wt.typeInfo;
		if (info == null) wt.typeInfo = info = WasmGcTypeInfo.new(wt);
		return info;
	}

	// Helper for completeTypes; processes (IrClass,WasmHeapType) pairs
	private def completeFromIrClass(cls: IrClass, wt: WasmHeapType) {
		var wst = WasmStructType.!(wt);
		var info = getTypeInfo(wst);
		if (wst.parent != null) {
			var pinfo = getTypeInfo(wst.parent);
			info.addOutEdge(pinfo);
			pinfo.addInEdge(info);
		}
		for (m in cls.methods) {
			var wft = signatureMap[m.sig];
			var finfo = getTypeInfo(wft);
			info.addOutEdge(finfo);
			finfo.addInEdge(info);
		}
		for (i < cls.fields.length) {
			var ftype = cls.fields[i].fieldType;
			var wft = heapTypeMap[ftype];
			if (wft == null) {
				// EBM: check about mutability
				wst.fields[i] = (packingForType(ftype), getValueTypeFor(ftype), true);
			} else {
				var finfo = getTypeInfo(wft);
				info.addOutEdge(finfo);
				finfo.addInEdge(info);
				// EBM: check about mutability
				wst.fields[i] = (WasmPacking.NONE, WasmValueType.RefNull(wft), true);
			}
		}
		wt.complete = true;
	}

	// Helper for completeTypes; processes (Type,WasmHeapType) pairs
	private def completeFromType(t: Type, wt: WasmHeapType) {
		if (wt.complete) return;
		var info = getTypeInfo(wt);
		match (t.typeCon.kind) {
			ARRAY => {
				var wat = WasmArrayType.!(wt);
				var eltype = V3Array.elementType(t);
				var vtype = getValueTypeFor(eltype);
				// EBM: consider packing at some point
				wat.elem = (WasmPacking.NONE, vtype);
				var wet = heapTypeMap[eltype];
				if (wet != null) {
					var einfo = getTypeInfo(wet);
					info.addOutEdge(einfo);
					einfo.addInEdge(info);
				}
			}
			FUNCREF, CLOSURE => {
				var wft = WasmFuncType.!(wt);
				var sig = FuncType.!(t).sig();
				for (i < sig.paramTypes.length) {
					wft.params[i] = getValueTypeFor(sig.paramTypes[i]);
					var wpt = heapTypeMap[sig.paramTypes[i]];
					if (wpt != null) {
						var pinfo = getTypeInfo(wpt);
						info.addOutEdge(pinfo);
						pinfo.addInEdge(info);
					}
				}
				for (i < sig.returnTypes.length) {
					wft.results[i] = getValueTypeFor(sig.returnTypes[i]);
					var wrt = heapTypeMap[sig.returnTypes[i]];
					if (wrt != null) {
						var rinfo = getTypeInfo(wrt);
						info.addOutEdge(rinfo);
						rinfo.addInEdge(info);
					}
				}
			}
			_ => ;	// should not happen
		}
		wt.complete = true;
	}

	// completeTypes fills in the stub WasmType's created by the
	// WasmGcIrTypeVisitor, in preparation for finding recursion groups,
	// etc.  To assist findTypeGroups, completeTypes builds predecessor
	// and successor sets for each WasmHeapType by creating
	// WasmGcTypeInfo information and adding edges to it.
	private def completeTypes() {
		classMap.apply(completeFromIrClass);
		heapTypeMap.apply(completeFromType);
	}

	// Support for dfs0 helper
	private def dfs0_visit(stack: Vector<WasmGcTypeInfo>, node: WasmGcTypeInfo) {
		if (node.visited) return;
		node.visited = true;
		var e = node.successors;
		while (e != null) {
			dfs0_visit(stack, e.dest);
			e = OutEdge.!(e.next);
		}
		stack.put(node);
	}

	// Helper for first depth-first search of the type graph
	private def dfs0(stack: Vector<WasmGcTypeInfo>, t: Type, wt: WasmHeapType) {
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
		// Note: we don't use getTypeInfo here so that we catch any
		// case where the info is absent
		dfs0_visit(stack, wt.typeInfo);
	}

<<<<<<< HEAD
	// Builds a single strongly connected component by doing a DFS from a
	// given node over predecessors
=======
	// Builds a single stroncgly connected component by doing a DFS from a
	// given node over predecessors (vs successors)
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
	private def dfs1(comp: Vector<WasmGcTypeInfo>, node: WasmGcTypeInfo) {
		if (node.visited) return;
		node.visited = true;
		comp.put(node);
<<<<<<< HEAD
		for (e = node.predecessors; e != null; e = e.tail) {
			dfs1(comp, e.head);
=======
		var e = node.predecessors;
		while (e != null) {
			dfs1(comp, e.dest);
			e = InEdge.!(e.next);
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
		}
	}

	// After a pass over the classes (etc.), we should have enough types
	// entered, with their WasmType's, to form recursion groups and assign
	// type indices.  We do this by running a strongly connected
	// components (SCC) algorithm over the graph of types.  Once we have
	// the SCCs, we order them by repeatedly finding SCCs all of whose
	// predecessors have already been found.
	private def findTypeGroups() {
		// This is an implementation of the Kosaraju-Sharir algorithm.

		// Step 1: Do a depth-first search and push nodes on a stack
		// in the order in which we *finish* with them.
<<<<<<< HEAD
		var stack = ListStack<WasmGcTypeInfo>.new();
		heapTypeMap.apply(dfs0(stack, _, _));
		// reset visited for second DFS
		for (node = stack.top; node != null; node = node.tail) {
			node.head.visited = false;
		}

		// Step 2: Do a depth-first search *over successors* to find
		// components.  Importantly, this proceeds in reverse of the
		// order in which Step 1 pushed nodes.
		var components = Vector<Vector<WasmGcTypeInfo>>.new();
		while (!stack.empty()) {
			var node = stack.pop();
=======
		var stack = Vector<WasmGcTypeInfo>.new();
		heapTypeMap.apply(dfs0(stack, _, _));
		// reset visited for second DFS
		for (i < stack.length) stack[i].visited = false;

		// Step 2: Do a depth-first search *over predecessors* to find
		// components.  Importantly, this proceeds in reverse of the
		// order in which Step 1 pushed nodes.
		var components = Vector<Vector<WasmGcTypeInfo>>.new();
		for (i = stack.length; --i >= 0; void) {
			var node = stack[i];
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
			if (node.visited) continue;
			var comp = Vector<WasmGcTypeInfo>.new();
			dfs1(comp, node);
			components.put(comp);
		}
<<<<<<< HEAD

		// At this point the components vector has the type groups in
		// forward order.  This is because, in stack, if there is a
		// forward path from node u to node v, then either they are in
		// the same component (in which case the order of u and v is
		// arbitrary) or u was pushed to the stack *after* v.  This
		// means that if u and v lie in different components and there
		// is a path from u to v, u's component will occur earlier in
		// components than v's will.  Each component is a recursion
		// group for Wasm type purposes, though singletons will not be
		// output as recursion groups.

		// We reverse the lsit so that we get leaves first.
		typeGroups = components.reverse();
=======
		// At this point the components vector has the type groups in
		// the necessary order.  This is because, in stack, if there
		// is a forward path from node u to node v, then either they
		// are in the same component (in which case the order of u and
		// v is arbitrary) or u was pushed to the stack *after* v.
		// This means that if u and v lie in different components and
		// there is a path from u to v, u's component will occur
		// earlier in components than v's will.  Each component is a
		// recursion group for Wasm type purposes, though singleton's
		// will not be output as recursion groups.
		typeGroups = components;
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
	}

	// This fills in fields (etc.) of types entered so far, then finds the
	// recursion groups of types and assign type indices.  Any types
	// encountered later may refer to these types, but may not be recursive.
	// Such types should be added using insureTypeAdded.
	def assignTypeIndices() {
<<<<<<< HEAD
=======
		completeTypes();
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
		findTypeGroups();
		var idx: i32 = 0;
		for (i < typeGroups.length) {
			var group = typeGroups[i];
			for (j < group.length) {
				group[j].wtype.index = ++maxIndex;
			}
		}
	}

	// This returns Wasm value types, not heap types
	// Non-recursive ("top-level") function
	def addValueType(t: Type) -> WasmValueType {
		match (t) {
			null => return WasmValueType.Void;
			x: IntType => return if(x.width > 32, WasmValueType.I64, WasmValueType.I32);
			x: FloatType => return if(x.is64, WasmValueType.F64, WasmValueType.F32);
<<<<<<< HEAD
			x: AnyRefType => return WasmValueType.AnyRef;
			x: NullType => return WasmValueType.NoneRef;
			_ => match (t.typeCon.kind) {
				ENUM => return wasmType(V3.getVariantTagType(t));
				ENUM_SET => return wasmType(V3.getEnumSetType(t));
				ARRAY, CLASS, VARIANT, FUNCREF =>
=======
			_ => match (t.typeCon.kind) {
				ENUM => return wasmType(V3.getVariantTagType(t));
				ENUM_SET => return wasmType(V3.getEnumSetType(t));
				ARRAY, CLASS, VARIANT, FUNCREF, POINTER =>
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
			 	      return addWasmRefType(t); // TODO
				_ => return WasmValueType.Void;
			}
		}
	}

	// Wraps a heap type with a layer of Wasm ref
<<<<<<< HEAD
	private def addWasmRefType(t: Type) -> WasmValueType {
		var wht = addHeapType(t);
		if (wht == null) {
			// System.err.puts(t.render(StringBuilder.new()).put1("addWasmRefType got null for %q\n", t.render).extract());
			var i = 1/0;
		}
		return WasmValueType.RefNull(wht);
=======
	// Non-recursive ("top-level") function
	private def addWasmRefType(t: Type) -> WasmValueType {
		addHeapType(t, null);
		return WasmValueType.RefNull(heapTypeMap[t]);
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
	}

	// This returns Wasm value types, not heap types
	// Non-recursive ("top-level") function
	def getValueTypeFor(t: Type) -> WasmValueType {
		match (t) {
			null => return WasmValueType.Void;
			x: IntType => return if(x.width > 32, WasmValueType.I64, WasmValueType.I32);
			x: FloatType => return if(x.is64, WasmValueType.F64, WasmValueType.F32);
<<<<<<< HEAD
			x: AnyRefType => return WasmValueType.AnyRef;
			x: NullType => return WasmValueType.NoneRef;
			_ => match (t.typeCon.kind) {
				ENUM => return wasmType(V3.getVariantTagType(t));
				ENUM_SET => return wasmType(V3.getEnumSetType(t));
				ARRAY, CLASS, VARIANT, FUNCREF =>
			 	      return addWasmRefType(t);
=======
			_ => match (t.typeCon.kind) {
				ENUM => return wasmType(V3.getVariantTagType(t));
				ENUM_SET => return wasmType(V3.getEnumSetType(t));
				ARRAY, CLASS, VARIANT, FUNCREF, POINTER =>
			 	      return WasmValueType.RefNull(heapTypeMap[t]);
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
				_ => return WasmValueType.Void;
			}
		}
	}
<<<<<<< HEAD
	def getStorageTypeFor(t: Type, mutable: bool) -> WasmStorageType {
		return WasmStorageType(packingForType(t), getValueTypeFor(t), mutable);
	}
	def packingForType(t: Type) -> WasmPacking {
		match (t) {
			x: IntType => {
				if (x.width <= 8) return WasmPacking.PACKED_8;
				else if (x.width <= 16) return WasmPacking.PACKED_16;
				else return WasmPacking.NONE;
=======

	def packingForType(t: Type) -> WasmPacking {
		match (t) {
			x: IntType => {
				if (x.width <= 8) {
					return if(x.signed, WasmPacking.PACKED_8S, WasmPacking.PACKED_8U);
				} else if (x.width <= 16) {
					return if(x.signed, WasmPacking.PACKED_16S, WasmPacking.PACKED_16U);
				}
				return WasmPacking.NONE;
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
			}
			_ => return WasmPacking.NONE;
		}
	}

	// This is used after the initial building of the types table from
	// IrModule information, to insure that types encountered in code
	// (etc.?) are added to the type table.  They should form (at most) an
	// acyclic graph of new nodes untilmately referring only to scalar
	// type or types previously entered.
	def insureTypeAdded(typ: Type) {
<<<<<<< HEAD
		if (heapTypeMap[typ] != null) {
			// EBM maybe check that the WasmHeapType is complete
=======
		var ht = heapTypeMap[typ];
		if (ht != null) {
			// if (!ht.complete) error;
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
			return;
		}
		match (typ.typeCon.kind) {
			ARRAY => {
<<<<<<< HEAD
				// make sure the element type is recorded first (if a heap type)
				var etype = V3Array.elementType(typ);
				insureTypeAdded(etype);
				// make sure the array type is constructed and recorded
				var wat = addArrayType(typ);
				// assign type index if necessary
				if (wat.index == 0) {
					typeGroups.put(Vectors.of1<WasmGcTypeInfo>(wat.getTypeInfo()));
					wat.index = ++maxIndex;
					wat.complete = true;
				}
=======
				// insert stub
				var wat = WasmArrayType.new((WasmPacking.NONE, WasmValueType.Void));
				heapTypeMap[typ] = wat;
				var info = getTypeInfo(wat);	// should always return a new WasmGcTypeInfo
				// add element type (ignored if scalar, etc.)
				insureTypeAdded(typ.nested.head);
				wat.complete = true;
				typeGroups.put(Vectors.of1<WasmGcTypeInfo>(info));
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
				return;
			}
			CLASS, VARIANT => return;	// should not happen
			FUNCREF, CLOSURE => {
				if (FuncType.?(typ)) {
					var sig = FuncType.!(typ).sig();
					// check if already canonicalized
<<<<<<< HEAD
					if (signatureMap[sig] != null) return;
					addSignature(sig);
					var wht = signatureMap[sig];
					// assign type index if necessary
					if (wht.index == 0) {
						var wft = WasmFuncType.!(wht);
						// make sure that all mentioned types are recorded first
						for (i < sig.paramTypes.length) {
							var t = sig.paramTypes[i];
							insureTypeAdded(t);
							wft.params[i] = getValueTypeFor(t);
						}
						for (i < sig.returnTypes.length) {
							var t = sig.returnTypes[i];
							insureTypeAdded(t);
							wft.results[i] = getValueTypeFor(t);
						}
						// add the WsmFuncType to the type groups
						typeGroups.put(Vectors.of1<WasmGcTypeInfo>(wft.getTypeInfo()));
						wft.index = ++maxIndex;
						wft.complete = true;
					}
=======
					if (signatureMap.has(sig)) return;
					addSignature(sig);
					var wft = signatureMap[sig];
					var info = getTypeInfo(wft);	// should always return a new WasmGcTypeInfo
					completeFromType(typ, wft);
					for (t in sig.paramTypes) insureTypeAdded(t);
					for (t in sig.returnTypes) insureTypeAdded(t);
					wft.complete = true;
					typeGroups.put(Vectors.of1<WasmGcTypeInfo>(info));
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
				}
				return;
			}
			_ => return;	// ignore if not actually a heap type
		}
	}

	def emit(out: DataWriter) {
<<<<<<< HEAD
		// System.err.puts("outputting ").puti(typeGroups.length).puts(" typegroups\n");
		var cnt = 0;
		for (i < typeGroups.length) {
			var group = typeGroups[i];
			if (group.length > 1) {
				out.putb(WasmDefTypeCode.REC.code);
				out.put_uleb32(u32.!(group.length));
			}
			for (j < group.length) {
				// System.err.puts("type ").puti(cnt++).puts(" [#").puti(cnt).puts("] (").puti(i).puts("): ");
				match (group[j].wtype) {
					ft: WasmFuncType => {
						// System.err.puts("function(");
						out.putb(WasmDefTypeCode.Function.code);
						if (ft.params.length == 1 && WasmValueType.Void.?(ft.params[0])) {
							// System.err.puts("<empty>");
							out.put_uleb32(0);
						} else {
							out.put_uleb32(u32.!(ft.params.length));
							for (k < ft.params.length) {
								// System.err.puts(if(k > 0, ", ", "")).puts(StringBuilder.new().put1("%q", ft.params[k].render).extract());
								ft.params[k].put(out);
							}
						}
						if (ft.results.length == 1 && WasmValueType.Void.?(ft.results[0])) {
							// System.err.puts(")").ln();
							out.put_uleb32(0);
						} else {
							// System.err.puts(")").puts(if(ft.results.length > 0, " -> ", "")).puts(if(ft.results.length > 1, "(", ""));
							out.put_uleb32(u32.!(ft.results.length));
							for (k < ft.results.length) {
								// System.err.puts(if(k > 0, ", ", "")).puts(StringBuilder.new().put1("%q", ft.results[k].render).extract());
								ft.results[k].put(out);
							}
							// System.err.puts(if(ft.results.length > 1, ")", "")).ln();
						}
					}
					st: WasmStructType => {
						// System.err.puts("struct(");
						if (st.parent != null) {
							// System.err.puts("super=").puti(st.parent.index).puts(if(st.fields.length > 0, ", ", ""));
							out.putb(WasmDefTypeCode.SUB.code);
							out.put_uleb32(1);
							out.put_uleb32(st.parent.index);
						}
						out.putb(WasmDefTypeCode.Struct.code);
						out.put_uleb32(u32.!(st.fields.length));
						for (k < st.fields.length) {
							// System.err.puts(StringBuilder.new().put1("%q", st.fields[k].render).extract()).puts(if(k + 1 < st.fields.length, ", ", ""));
							st.fields[k].put(out);
						}
						// System.err.puts(")\n");
					}
					at: WasmArrayType => {
						out.putb(WasmDefTypeCode.Array.code);
						// System.err.puts(StringBuilder.new().put1("(array %q)\n", at.elem.render).extract());
						at.elem.put(out);
					}
					_ => { /* error */ }
				}
			}
		}
=======
		// out.putr(buf.alias());
>>>>>>> b80970115 (Work to date on the Wasm GC beck end.  Will continue this work on this branch.)
	}
}
