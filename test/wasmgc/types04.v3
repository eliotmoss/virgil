//@execute 0=true; 1=false

// A test of type hierarchy and method overrides

class A {
	var x: int;
	new(x) { }
	def get() -> int { return x; }
}
class B1 extends A {
	var y1: int;
	new(x: int, y1) super(x) { }
	def get() -> int { return A.get(this) + y1; }
}
class B2 extends A {
	var y2: int;
	new(x: int, y2) super(x) { }
	def get() -> int { return A.get(this) + y2; }
}
class C1 extends B1 {
	var z1: int;
	new(x: int, y: int, z1) super(x, y) { }
	def get() -> int { return B1.get(this) + z1; }
}
class C2 extends B1 {
	var z2: int;
	new(x: int, y: int, z2) super(x, y) { }
	def get() -> int { return B1.get(this) + z2; }
}

def main(args: Array<string>) -> int {
	var a: A;
	match (args.length) {
		1 => a = A.new(args[0].length);
		2 => a = B1.new(args[1].length, args[2].length);
		3 => a = B2.new(args[1].length, args[2].length);
		4 => a = C1.new(args[1].length, args[2].length, args[3].length);
		5 => a = C2.new(args[1].length, args[2].length, args[3].length);
	}
	var v = a.get() + A.get(a) +
		if(B1.?(a), B1.get(B1.!(a)), 0) +
		if(B2.?(a), B2.get(B2.!(a)), 0) +
		if(C1.?(a), C1.get(C1.!(a)), 0) +
		if(C2.?(a), C2.get(C2.!(a)), 0);
	return v;
}
